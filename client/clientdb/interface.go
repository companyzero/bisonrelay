package clientdb

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/companyzero/bisonrelay/client/clientintf"
	"github.com/companyzero/bisonrelay/ratchet"
	"github.com/companyzero/bisonrelay/ratchet/disk"
	"github.com/companyzero/bisonrelay/rpc"
	"github.com/companyzero/bisonrelay/zkidentity"
	"golang.org/x/exp/slices"
)

type UserID = clientintf.UserID
type PostID = clientintf.PostID
type RawRVID = clientintf.RawRVID
type SendQID = clientintf.ID
type FileID = clientintf.ID
type ChunkID = clientintf.ID

type ReadTx interface {
	Context() context.Context
}

type ReadWriteTx interface {
	ReadTx
	Writable() bool
}

type KXStage uint8

const (
	KXStageUnknown KXStage = iota
	KXStageStep2IDKX
	KXStageStep3IDKX
)

func (stage KXStage) String() string {
	switch stage {
	case KXStageUnknown:
		return "unknown"
	case KXStageStep2IDKX:
		return "step2idkx"
	case KXStageStep3IDKX:
		return "step3idkx"
	default:
		return fmt.Sprintf("[unknown %d]", stage)
	}
}

// KXData holds information about outstanding KX sessions. In the description
// of the fields, the "source" user is the one that generated the initial
// invite and the "target" user is the one accepting the invite.
type KXData struct {
	// Public is the identity of the remote user. This is empty for the
	// source user and filled with the source user's public id on the
	// target user.
	Public zkidentity.PublicIdentity `json:"public"`

	// InitialRV is the random RV generated by the source user.
	InitialRV RawRVID `json:"initial_rv"`

	// Step3RV is the random RV generated by the target user.
	Step3RV RawRVID `json:"step3_rv"`

	// HalfRatchet is filled by the target user, after accepting the invite
	// but before the source user replied with their half ratchet in
	// Step3RV.
	HalfRatchet *disk.RatchetState `json:"half_ratchet"`

	// MyResetRV is the RV that the local client listens to for reset
	// requests from the remote client.
	MyResetRV RawRVID `json:"my_resetrv"`

	// TheirResetRV is the RV that the remote client listens to for
	// reset requests from the local client.
	TheirResetRV RawRVID `json:"their_resetrv"`

	// Stage is the current stage of the KX process.
	Stage KXStage `json:"stage"`

	// Timestamp is the time when this KX data was stored.
	Timestamp time.Time `json:"timestamp"`

	// Invitee is set in the source user when the the invite was created
	// to be fulfilled by a known target user, usually as a result of
	// a mediated KX.
	Invitee *zkidentity.PublicIdentity `json:"invitee"`

	// IsForReset flags whether this KX request was initiated by a reset
	// request.
	IsForReset bool `json:"is_for_reset"`

	// MediatorID is the identity of a remote user that requested this
	// invite be created (not the source user).
	MediatorID *UserID `json:"mediator_id"`
}

// AddressBookEntry stores contact information of a remote user.
type AddressBookEntry struct {
	ID           *zkidentity.PublicIdentity `json:"id"`
	MyResetRV    RawRVID                    `json:"myResetRV"`
	TheirResetRV RawRVID                    `json:"theirResetRV"`
	Ignored      bool                       `json:"ignored"`

	// FirstCreated tracks when the address book entry was first created
	// (i.e. first time this user was KX'd with).
	FirstCreated time.Time `json:"first_created"`

	// LastHandshake is the last time when the local client attempted
	// to start a handshake with this remote user.
	LastHandshakeAttempt time.Time `json:"last_handshake_attempt,omitempty"`

	// NickAlias is a local alias to the user (a replacement to the
	// original nick stored in the PublicIdentity). Only used if non-empty.
	NickAlias string `json:"nick_alias"`

	// LastCompletedKX is the last time a KX was completed with this user
	// (either the initial KX or a reset).
	//
	// Note: old gc entries may have a zeroed value for this field.
	LastCompletedKX time.Time `json:"last_completed_kx"`
}

// Nick returns the nick of the user.
func (abe *AddressBookEntry) Nick() string {
	if abe.NickAlias != "" {
		return abe.NickAlias
	}
	return abe.ID.Nick
}

// AddressBookAndRatchet stores both the address book entry and ratchet data of
// a remote user.
type AddressBookAndRatchet struct {
	AddressBook *AddressBookEntry
	Ratchet     *ratchet.Ratchet
}

// GroupChat is a GC structure. It includes the GC metadata plus additional
// fields needed to manage it.
type GroupChat struct {
	// Note: Metadata MUST be the first field (for the time being) because
	// it is used to disambiguate the on-disk structure when loading a GC.

	// Metadata is the latest metadata known about the GC.
	Metadata rpc.RMGroupList `json:"metadata"` // DO NOT

	// Alias is a local alias for the GC. This may be empty, in which
	// case the Metadata.Name field is used.
	Alias string `json:"alias"`

	// RTDTSessionRV when non-empty is the RTDT session RV associated to
	// this GC.
	RTDTSessionRV *zkidentity.ShortID `json:"rtdt_session_rv"`
}

// DeepCopy makes a deep copy of this GC so that the copy can be modified.
func (gc *GroupChat) DeepCopy() GroupChat {
	res := *gc

	// Ok to do a "shallow" copy for these because the items are values (as
	// opposed to pointers).
	res.Metadata.Members = slices.Clone(gc.Metadata.Members)
	res.Metadata.ExtraAdmins = slices.Clone(gc.Metadata.ExtraAdmins)
	return res
}

// Name returns either the local alias (if one is set) or the GC name.
func (gc *GroupChat) Name() string {
	if gc.Alias != "" {
		return gc.Alias
	}

	return gc.Metadata.Name
}

type GCAddressBookEntry struct {
	ID      zkidentity.ShortID `json:"id"`
	Members []UserID           `json:"members"`
}

func RMGroupListToGCEntry(gc *rpc.RMGroupList, entry *GCAddressBookEntry) {
	entry.ID = gc.ID
	entry.Members = make([]UserID, len(gc.Members))
	copy(entry.Members, gc.Members)
}

type SharedFile struct {
	// FileHash is the hash of the file contents.
	FileHash clientintf.ID `json:"file_hash"`

	// FID is the file id (hash of the metadata, which also includes the
	// content hash).
	FID FileID `json:"fid"`

	// Filename is the base filename of the file.
	Filename string `json:"filename"`
}

// SharedFileAndShares tracks all the shares made for the given shared file.
type SharedFileAndShares struct {
	SF     SharedFile      `json:"shared_file"`
	Cost   uint64          `json:"cost"`
	Size   uint64          `json:"size"`
	Global bool            `json:"global"`
	Shares []clientintf.ID `json:"shares"`
}

type ChunkState string

const (
	ChunkStateHasInvoice     ChunkState = "has_invoice"
	ChunkStatePayingInvoice  ChunkState = "paying_invoice"
	ChunkStateSentInvoice    ChunkState = "sent_invoice"
	ChunkStateRequestedChunk ChunkState = "requested_chunk"
	ChunkStatePaid           ChunkState = "paid"
	ChunkStateUploaded       ChunkState = "uploaded"
	ChunkStateDownloaded     ChunkState = "downloaded"
)

type FileDownload struct {
	UID              UserID             `json:"uid"`
	FID              FileID             `json:"fid"`
	CompletedName    string             `json:"completed_name"`
	Metadata         *rpc.FileMetadata  `json:"metadata"`
	Invoices         map[int]string     `json:"invoices"` // Key is chunk index
	ChunkStates      map[int]ChunkState `json:"chunkstates"`
	ChunkUpdatedTime map[int]time.Time  `json:"chunkupdttimes"`
	IsSentFile       bool               `json:"is_sent_file"`
	DiskPath         string             `json:"disk_path"` // Set when completed
}

func (fd *FileDownload) GetChunkState(chunkIdx int) ChunkState {
	if fd.ChunkStates == nil {
		return "**nil chunk state map"
	}
	cs, ok := fd.ChunkStates[chunkIdx]
	if !ok {
		return "**chunk idx does not exist"
	}
	return cs
}

func (fd *FileDownload) GetChunkInvoice(chunkIdx int) string {
	if fd.Invoices == nil {
		return "**nil chunk invoices"
	}
	inv, ok := fd.Invoices[chunkIdx]
	if !ok {
		return "**chunk idx does not have invoice"
	}
	return inv
}

// CountChunks returns how many chunks there are at the given chunk state.
func (fd *FileDownload) CountChunks(atState ChunkState) int {
	var res int
	for _, cs := range fd.ChunkStates {
		if cs == atState {
			res += 1
		}
	}
	return res
}

type ChunkUpload struct {
	UID      UserID     `json:"uid"`
	FID      FileID     `json:"fid"`
	CID      ChunkID    `json:"hash"`
	Index    int        `json:"index"`
	Invoices []string   `json:"invoice"`
	Paid     int        `json:"paid"`
	State    ChunkState `json:"state"`
}

type RemoteFile struct {
	FID      FileID           `json:"file_id"`
	UID      UserID           `json:"uid"`
	DiskPath string           `json:"disk_path"`
	Metadata rpc.FileMetadata `json:"metadata"`
}

type PostSummary struct {
	ID           PostID    `json:"id"`
	From         UserID    `json:"from"`
	AuthorID     UserID    `json:"author_id"`
	AuthorNick   string    `json:"author_nick"`
	Date         time.Time `json:"date"`
	LastStatusTS time.Time `json:"last_status_ts"`
	Title        string    `json:"title"`
}

type PostSubscription struct {
	To   UserID    `json:"to"`
	Date time.Time `json:"date"`
}

// SendQueueFileChunk is used when a SendQueueElement is support to refer to
// a file chunk instead of an RM.
type SendQueueFileChunk struct {
	Filename string `json:"filename"`
	Offset   int64  `json:"offset"`
	Size     int64  `json:"size"`
	RMType   string `json:"rm_type"`
	FileID   string `json:"file_id"`
	Index    int    `json:"index"`
}

// ReadChunkData reads the chunk data into out.
func (fc *SendQueueFileChunk) ReadChunkData(out []byte) ([]byte, error) {
	// Read the file chunk.
	f, err := os.Open(fc.Filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	offset, err := f.Seek(fc.Offset, 0)
	if err != nil {
		return nil, err
	}
	if offset != fc.Offset {
		return nil, fmt.Errorf("seek error: read to offset %d instead of %d",
			offset, fc.Offset)
	}

	// Size read buffer.
	out = slices.Grow(out[:0], int(fc.Size))[:fc.Size]
	n, err := f.Read(out)
	if err != nil {
		return nil, err
	}
	if int64(n) != fc.Size {
		return nil, fmt.Errorf("not enough bytes read: read %d, want %d",
			n, fc.Size)
	}
	return out, nil
}

// RM generates the RM that this file chunk should use (including its contents).
func (fc *SendQueueFileChunk) RM() (interface{}, error) {
	switch fc.RMType {
	case rpc.RMCFTGetChunkReply:
		buf, err := fc.ReadChunkData(nil)
		if err != nil {
			return nil, err
		}

		return rpc.RMFTGetChunkReply{
			FileID: fc.FileID,
			Index:  fc.Index,
			Chunk:  buf,
		}, nil
	default:
		return nil, fmt.Errorf("unknown SendQueueFileChunk type %q",
			fc.RMType)
	}
}

// SendQueueElement is one item in the outbound send queue.
type SendQueueElement struct {
	ID       clientintf.ID `json:"id"`
	Type     string        `json:"type"`
	Dests    []UserID      `json:"dests"`
	Msg      []byte        `json:"msg"`
	Priority uint          `json:"priority"`
	AddTs    int64         `json:"add_ts"`

	// FileChunk is set when this element is for an outbound file chunk.
	FileChunk *SendQueueFileChunk `json:"file_chunk"`
}

// KXSeachQuery holds a specific target used while searching for a KX.
type KXSearchQuery struct {
	User        clientintf.ID   `json:"user"`
	DateSent    time.Time       `json:"date_sent"`
	IDsReceived []clientintf.ID `json:"ids_received"`
}

// KXSearch holds the queries performed when searching for a user.
type KXSearch struct {
	Target  clientintf.ID   `json:"target"`
	Search  rpc.RMKXSearch  `json:"search"`
	Queries []KXSearchQuery `json:"queries"`
}

// MediateIDRequest is used to track in flight mediate identity requests.
type MediateIDRequest struct {
	Mediator UserID    `json:"mediator"`
	Target   UserID    `json:"target"`
	Date     time.Time `json:"date"`
	Manual   bool      `json:"manual"` // Manual as opposed to auto kx.
}

type PostKXActionType string

const (
	PKXActionKXSearch  PostKXActionType = "kx_search"
	PKXActionFetchPost PostKXActionType = "fetch_post"
	PKXActionInviteGC  PostKXActionType = "invite_gc"
)

type PostKXAction struct {
	Type      PostKXActionType `json:"type"`
	DateAdded time.Time        `json:"date_added"`
	Data      string           `json:"data"`
}

type PayStatEvent struct {
	Timestamp int64  `json:"ts"`
	Event     string `json:"event"`
	Amount    int64  `json:"amount"`
	PayFee    int64  `json:"pay_fee"`
}

type UserPayStats struct {
	TotalSent     int64 `json:"total_sent"`
	TotalReceived int64 `json:"total_received"`
	TotalPayFee   int64 `json:"total_pay_fee"`
}

type PayStatsSummary struct {
	Prefix string `json:"prefix"`
	Total  int64  `json:"total"`
}

// UnackedRM is an already encrypted but unacked RM.
type UnackedRM struct {
	UID       UserID  `json:"uid"`
	Encrypted []byte  `json:"encrypted"`
	RV        RawRVID `json:"rv"`
	PayEvent  string  `json:"pay_event"`
}

type TipUserAttempt struct {
	UID                  UserID     `json:"uid"`
	Tag                  int32      `json:"tag"`
	MilliAtoms           uint64     `json:"milli_atoms"`
	Created              time.Time  `json:"created"`
	Attempts             int32      `json:"attempts"`
	MaxAttempts          int32      `json:"max_attempts"`
	InvoiceRequested     *time.Time `json:"invoice_requested"`
	PaymentAttempt       *time.Time `json:"payment_attempt"`
	PaymentAttemptCount  uint32     `json:"payment_attempt_count"`
	PaymentAttemptFailed *time.Time `json:"payment_attempt_failed"`
	LastInvoice          string     `json:"last_invoice"`
	PrevInvoices         []string   `json:"prev_invoices"`
	LastInvoiceError     *string    `json:"last_invoice_error,omitempty"`
	Completed            *time.Time `json:"completed,omitempty"`
}

// ResourceRequest is a serialized request for a resource.
type ResourceRequest struct {
	UID           UserID                    `json:"uid"`
	Timestamp     time.Time                 `json:"timestamp"`
	Request       rpc.RMFetchResource       `json:"request"`
	SesssionID    clientintf.PagesSessionID `json:"session_id"`
	ParentPage    clientintf.PagesSessionID `json:"parent_page"`
	AsyncTargetID string                    `json:"async_target_id"`
}

// FetchedResource is the full information about a fetched resource from a
// remote client.
type FetchedResource struct {
	UID           UserID                    `json:"uid"`
	SessionID     clientintf.PagesSessionID `json:"session_id"`
	ParentPage    clientintf.PagesSessionID `json:"parent_page"`
	PageID        clientintf.PagesSessionID `json:"page_id"`
	RequestTS     time.Time                 `json:"request_ts"`
	ResponseTS    time.Time                 `json:"response_ts"`
	Request       rpc.RMFetchResource       `json:"request"`
	Response      rpc.RMFetchResourceReply  `json:"response"`
	AsyncTargetID string                    `json:"async_target_id"`
}

// PageSessionOverviewRequest is the overview of a fetch resource request.
type PageSessionOverviewRequest struct {
	UID           clientintf.UserID `json:"uid"`
	Tag           rpc.ResourceTag   `json:"tag"`
	AsyncTargetID string            `json:"async_target_id"`
}

// PageSessionOverviewResponse is the overview of a fetch resurce response.
type PageSessionOverviewResponse struct {
	ID            clientintf.PagesSessionID `json:"id"`
	Parent        clientintf.PagesSessionID `json:"parent"`
	AsyncTargetID string                    `json:"async_target_id"`
}

type BundledPageResponse struct {
	PagesMap map[string]clientintf.PagesSessionID `json:"pages_map"`
}

type BundledUserResponses struct {
	Bundles           map[clientintf.PagesSessionID]*BundledPageResponse `json:"bundles"`
	PagesToBundlesMap map[string]clientintf.PagesSessionID               `json:"pages_to_bundles_map"`
}

func (bur *BundledUserResponses) MarshalJSON() ([]byte, error) {
	return []byte{}, nil
}

type BundledUserResponsesMap map[clientintf.UserID]*BundledUserResponses

type bprJSON struct {
	PagesMap map[string]uint64 `json:"pages_map"`
}
type burJSON struct {
	Bundles           map[uint64]bprJSON `json:"bundles"`
	PagesToBundlesMap map[string]uint64  `json:"pages_to_bundles_map"`
}

func (burmap *BundledUserResponsesMap) MarshalJSON() ([]byte, error) {
	if burmap == nil {
		return []byte("{}"), nil
	}

	burmapJSON := make(map[string]burJSON, len(*burmap))
	for uid, bur := range *burmap {
		uidStr := uid.String()
		burmapJSON[uidStr] = burJSON{
			Bundles:           make(map[uint64]bprJSON, len(bur.Bundles)),
			PagesToBundlesMap: make(map[string]uint64, len(bur.PagesToBundlesMap)),
		}
		for bundleID, bpr := range bur.Bundles {
			burmapJSON[uidStr].Bundles[uint64(bundleID)] = bprJSON{
				PagesMap: make(map[string]uint64, len(bpr.PagesMap)),
			}
			for path, pageID := range bpr.PagesMap {
				burmapJSON[uidStr].Bundles[uint64(bundleID)].PagesMap[path] = uint64(pageID)
			}
		}
		for path, bundleID := range bur.PagesToBundlesMap {
			burmapJSON[uidStr].PagesToBundlesMap[path] = uint64(bundleID)
		}
	}
	return json.Marshal(burmapJSON)
}

func (burmap *BundledUserResponsesMap) UnmarshalJSON(b []byte) error {
	burmapJSON := make(map[string]burJSON, len(*burmap))
	err := json.Unmarshal(b, &burmapJSON)
	if err != nil {
		return err
	}

	*burmap = make(BundledUserResponsesMap, len(burmapJSON))
	bm := *burmap
	for uidStr, bur := range burmapJSON {
		var uid clientintf.UserID
		if err := uid.FromString(uidStr); err != nil {
			return fmt.Errorf("unable to convert %q to UserID: %v", uidStr, err)
		}

		bm[uid] = &BundledUserResponses{
			Bundles:           make(map[clientintf.PagesSessionID]*BundledPageResponse, len(bur.Bundles)),
			PagesToBundlesMap: make(map[string]clientintf.PagesSessionID, len(bur.PagesToBundlesMap)),
		}
		for bundleID, bpr := range bur.Bundles {
			bm[uid].Bundles[clientintf.PagesSessionID(bundleID)] = &BundledPageResponse{
				PagesMap: make(map[string]clientintf.PagesSessionID, len(bpr.PagesMap)),
			}
			for path, pageID := range bpr.PagesMap {
				bm[uid].Bundles[clientintf.PagesSessionID(bundleID)].PagesMap[path] = clientintf.PagesSessionID(pageID)
			}
		}
		for path, bundleID := range bur.PagesToBundlesMap {
			bm[uid].PagesToBundlesMap[path] = clientintf.PagesSessionID(bundleID)
		}
	}

	return nil
}

func (burmap *BundledUserResponsesMap) initBundledResponse(uid clientintf.UserID, bundleID clientintf.PagesSessionID) {
	if *burmap == nil {
		*burmap = make(map[clientintf.UserID]*BundledUserResponses)
	}
	bm := *burmap
	if bm[uid] == nil {
		bm[uid] = &BundledUserResponses{}
	}

	userBundles := bm[uid]
	if userBundles.Bundles == nil {
		userBundles.Bundles = make(map[clientintf.PagesSessionID]*BundledPageResponse)
	}
	if userBundles.PagesToBundlesMap == nil {
		userBundles.PagesToBundlesMap = make(map[string]clientintf.PagesSessionID)
	}
	if bundle, ok := userBundles.Bundles[bundleID]; !ok || bundle == nil {
		userBundles.Bundles[bundleID] = &BundledPageResponse{}
	}
	if userBundles.Bundles[bundleID].PagesMap == nil {
		userBundles.Bundles[bundleID].PagesMap = make(map[string]clientintf.PagesSessionID)
	}
}

func (burmap *BundledUserResponsesMap) setBundledUserReponse(uid clientintf.UserID, path string, bundleID, itemID clientintf.PagesSessionID) {
	userBundle := (*burmap)[uid]
	userBundle.Bundles[bundleID].PagesMap[path] = itemID
	userBundle.PagesToBundlesMap[path] = bundleID
}

func (burmap *BundledUserResponsesMap) getBundledUserPageID(uid clientintf.UserID, path string) (clientintf.PagesSessionID, bool) {
	if *burmap == nil {
		return 0, false
	}
	userBundle := (*burmap)[uid]
	if userBundle == nil {
		return 0, false
	}
	if userBundle.PagesToBundlesMap == nil || userBundle.Bundles == nil {
		return 0, false
	}
	bundleID, ok := userBundle.PagesToBundlesMap[path]
	if !ok {
		return 0, false
	}
	bundle := userBundle.Bundles[bundleID]
	if bundle == nil || bundle.PagesMap == nil {
		return 0, false
	}
	itemID, ok := bundle.PagesMap[path]
	if !ok {
		return 0, false
	}
	return itemID, true

}

// PageSessionOverview stores the overview of a pages session navigation.
type PageSessionOverview struct {
	Requests       []PageSessionOverviewRequest  `json:"requests"`
	Responses      []PageSessionOverviewResponse `json:"responses"`
	LastResponseTS time.Time                     `json:"last_response_ts"`
	LastRequestTS  time.Time                     `json:"last_request_ts"`

	BundledUserResponses BundledUserResponsesMap `json:"bundled_user_responses"`
}

func (o *PageSessionOverview) appendResponse(parent, id clientintf.PagesSessionID, asyncId string) {
	o.Responses = append(o.Responses, PageSessionOverviewResponse{
		Parent:        parent,
		ID:            id,
		AsyncTargetID: asyncId,
	})
	o.LastResponseTS = time.Now()
}

func (o *PageSessionOverview) removeRequest(uid clientintf.UserID, tag rpc.ResourceTag) {
	i := slices.IndexFunc(o.Requests, func(v PageSessionOverviewRequest) bool {
		return v.UID == uid && v.Tag == tag
	})
	if i > -1 {
		o.Requests = slices.Delete(o.Requests, i, i+1)
	}
}

func (o *PageSessionOverview) appendRequest(uid clientintf.UserID, tag rpc.ResourceTag, asyncId string) {
	o.Requests = append(o.Requests, PageSessionOverviewRequest{
		UID:           uid,
		Tag:           tag,
		AsyncTargetID: asyncId,
	})
	o.LastRequestTS = time.Now()
}

func (o *PageSessionOverview) initBundledResponse(uid clientintf.UserID, bundleID clientintf.PagesSessionID) {
	o.BundledUserResponses.initBundledResponse(uid, bundleID)
}

func (o *PageSessionOverview) setBundledUserReponse(uid clientintf.UserID, path string, bundleID, itemID clientintf.PagesSessionID) {
	o.BundledUserResponses.setBundledUserReponse(uid, path, bundleID, itemID)
}

func (o *PageSessionOverview) getBundledUserPageID(uid clientintf.UserID, path string) (clientintf.PagesSessionID, bool) {
	return o.BundledUserResponses.getBundledUserPageID(uid, path)
}

// pageAndAsyncChildren returns the page response (if it exists) and any async
// children derived from it.
//
// This returns at most one child for each async id (the latest one).
func (o *PageSessionOverview) pageAndAsyncChildren(id clientintf.PagesSessionID) []*PageSessionOverviewResponse {
	var res []*PageSessionOverviewResponse
	asyncIds := make(map[string]int) // Tracks index inside res

	for i := range o.Responses {
		r := &o.Responses[i]
		if r.ID != id && r.Parent != id {
			continue
		}

		// Handle the page itself.
		if r.ID == id {
			if len(res) == 0 {
				res = append(res, r)
			} else {
				res[0] = r
			}
			continue
		}

		// Handle async requests in the page.
		if r.AsyncTargetID == "" {
			continue
		}
		if idxToReplace, ok := asyncIds[r.AsyncTargetID]; ok {
			res[idxToReplace] = r
		} else {
			res = append(res, r)
			asyncIds[r.AsyncTargetID] = len(res) - 1
		}
	}

	return res
}

type PMLogEntry struct {
	Message   string `json:"message"`
	From      string `json:"from"`
	Timestamp int64  `json:"timestamp"`
	Internal  bool   `json:"internal"`
}

// UnkxdUserInfo tracks information about unxked users.
type UnkxdUserInfo struct {
	UID           UserID     `json:"uid"`
	MIRequests    uint32     `json:"mi_requests"`
	AddedToGCTime *time.Time `json:"added_to_gc_time"`
}

type GeneratedInvoiceForTip struct {
	UID        UserID    `json:"uid"`
	Created    time.Time `json:"created"`
	Invoice    string    `json:"invoice"`
	MilliAtoms uint64    `json:"milli_atoms"`
}

// ContentFilter stores filtering rules for content.
type ContentFilter struct {
	// ID is the local ID of the filter.
	ID uint64

	// UID of the user this filter applies to. If nil, this applies to all
	// users.
	UID *UserID

	// GC this filter applies to. If nil, this applies to all GCs.
	GC *zkidentity.ShortID

	// SkipPMs is true if this does not apply to PMs.
	SkipPMs bool

	// SkipGCMs is true if this does not apply to GCMs.
	SkipGCMs bool

	// SkipPosts is true if this is does not apply to posts.
	SkipPosts bool

	// SkipPostComments is true if this does not apply to post comments.
	SkipPostComments bool

	// Regexp is the raw filter to apply.
	Regexp string
}

// ReceiveReceipt stores receive receipt times.
type ReceiveReceipt struct {
	User       UserID `json:"user"`
	ServerTime int64  `json:"server_time"` // Unix Millisecond timestamp
	ClientTime int64  `json:"client_time"` // Unix Millisecond timestamp
}

// EarlyPostStatus stores data about a post status received before a post.
type EarlyPostStatus struct {
	PID    PostID          `json:"pid"`
	Status rpc.RMPostShare `json:"status"`
}

// RTDTSessionMember tracks the members of the RTDT session.
type RTDTSessionMember struct {
	UID               UserID         `json:"uid"`
	PeerID            rpc.RTDTPeerID `json:"peer_id"`
	Tag               uint64         `json:"tag"`
	SentTimestamp     int64          `json:"sent_timestamp"`
	Publisher         bool           `json:"publisher"`
	AcceptedTimestamp *int64         `json:"accepted_timestamp"`
	AppointCookie     []byte         `json:"appoint_cookie"`
}

// RTDTSession tracks data about a long-term RTDT session.
type RTDTSession struct {
	Metadata rpc.RMRTDTSession `json:"metadata"`

	// SessionCookie is set when we created/admin the session.
	SessionCookie []byte `json:"session_cookie"`

	// OwnerSecret is set when we created/admin the session.
	OwnerSecret *zkidentity.ShortID `json:"owner_secret"`

	// AppointCookie is used to request new join cookies from brserver.
	AppointCookie []byte `json:"appoint_cookie"`

	// PublisherKey is set when participating as a publisher.
	PublisherKey *zkidentity.FixedSizeSymmetricKey `json:"publisher_key"`

	// LocalPeerID is the ID of the local client within the rtdt server for
	// this session.
	LocalPeerID rpc.RTDTPeerID `json:"local_peer_id"`

	// NextPeerID is the ID to attribute to the next peer invited to the
	// session. Only set for the owner/admin.
	NextPeerID rpc.RTDTPeerID `json:"next_peer_id"`

	// Members is the list of members of the session.
	Members []RTDTSessionMember `json:"members"`

	// GC when non-empty is the id of the GC associated with this RTDT
	// session.
	GC *zkidentity.ShortID `json:"gc"`
}

// MemberUIDs returns the user IDs of all members, _except_ for one user.
func (sess *RTDTSession) MemberUIDs(exclude UserID) []UserID {
	res := make([]UserID, 0, len(sess.Members))
	for i := range sess.Members {
		m := sess.Members[i]
		if m.UID == exclude {
			continue
		}
		res = append(res, m.UID)
	}
	return res
}

// IsPeerPublisher returns true if the given id corresponds to a publisher.
func (sess *RTDTSession) IsPeerPublisher(id rpc.RTDTPeerID) bool {
	for i := range sess.Metadata.Publishers {
		if sess.Metadata.Publishers[i].PeerID == id {
			return true
		}
	}
	return false
}

// LocalIsAdmin returns true if the local client is an admin of this session.
func (sess *RTDTSession) LocalIsAdmin() bool {
	return len(sess.SessionCookie) > 0
}

// MemberIndices returns the index of an uid inside the members and publishers
// lists.
func (sess *RTDTSession) MemberIndices(uid *UserID) (memberIndex int, publisherIndex int) {
	memberIndex = slices.IndexFunc(sess.Members, func(m RTDTSessionMember) bool {
		return m.UID == *uid
	})
	publisherIndex = slices.IndexFunc(sess.Metadata.Publishers, func(p rpc.RMRTDTSessionPublisher) bool {
		return p.PublisherID == *uid
	})
	return
}

// MembersMap returns a map from peer id to index in sess.Members.
func (sess *RTDTSession) MembersMap() map[rpc.RTDTPeerID]*RTDTSessionMember {
	res := make(map[rpc.RTDTPeerID]*RTDTSessionMember, len(sess.Members))
	for i := range sess.Members {
		res[sess.Members[i].PeerID] = &sess.Members[i]
	}
	return res
}

// RMMembersList converts the list of session members into a list of
// RMRTDTAdminMember.
func (sess *RTDTSession) RMMembersList() []rpc.RMRTDTAdminMember {
	res := make([]rpc.RMRTDTAdminMember, len(sess.Members))
	for i, member := range sess.Members {
		res[i] = rpc.RMRTDTAdminMember{
			UID:                member.UID,
			PeerID:             member.PeerID,
			AppointCookie:      member.AppointCookie,
			AllowedAsPublisher: member.Publisher,
		}
	}
	return res
}

var (
	ErrLocalIDEmpty         = errors.New("local ID is not initialized")
	ErrServerIDEmpty        = errors.New("server ID is not known")
	ErrNotFound             = errors.New("entry not found")
	ErrAlreadySubscribed    = errors.New("already subscribed")
	ErrNotSubscribed        = errors.New("not subscribed")
	ErrPostStatusValidation = errors.New("invalid post status update")
	ErrAlreadyExists        = errors.New("already exists")
	ErrDuplicatePostStatus  = errors.New("duplicate post status")
)
