// Code generated by protoc-gen-go-svcintf. DO NOT EDIT.
// source: clientrpc.proto

package types

import (
	context "context"
	proto "google.golang.org/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
)

// VersionServiceClient is the client API for VersionService service.
type VersionServiceClient interface {
	// Version returns version information about the server.
	Version(ctx context.Context, in *VersionRequest, out *VersionResponse) error
	// KeepaliveStream returns a stream where the server continuously writes
	// keepalive events.
	//
	// The stream only terminates if the client requests it or the connection to
	// the server is closed.
	KeepaliveStream(ctx context.Context, in *KeepaliveStreamRequest) (VersionService_KeepaliveStreamClient, error)
}

type client_VersionService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_VersionService) Version(ctx context.Context, in *VersionRequest, out *VersionResponse) error {
	const method = "Version"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type VersionService_KeepaliveStreamClient interface {
	Recv(*KeepaliveEvent) error
}

func (c *client_VersionService) KeepaliveStream(ctx context.Context, in *KeepaliveStreamRequest) (VersionService_KeepaliveStreamClient, error) {
	const method = "KeepaliveStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*KeepaliveEvent]{c: inner}, nil
}

func NewVersionServiceClient(c ClientConn) VersionServiceClient {
	return &client_VersionService{c: c, defn: VersionServiceDefn()}
}

// VersionServiceServer is the server API for VersionService service.
type VersionServiceServer interface {
	// Version returns version information about the server.
	Version(context.Context, *VersionRequest, *VersionResponse) error
	// KeepaliveStream returns a stream where the server continuously writes
	// keepalive events.
	//
	// The stream only terminates if the client requests it or the connection to
	// the server is closed.
	KeepaliveStream(context.Context, *KeepaliveStreamRequest, VersionService_KeepaliveStreamServer) error
}

type VersionService_KeepaliveStreamServer interface {
	Send(m *KeepaliveEvent) error
}

func VersionServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "VersionService",
		Methods: map[string]MethodDefn{
			"Version": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(VersionRequest) },
				NewResponse:  func() proto.Message { return new(VersionResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(VersionRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(VersionResponse).ProtoReflect().Descriptor() },
				Help:         "Version returns version information about the server.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(VersionServiceServer).Version(ctx, request.(*VersionRequest), response.(*VersionResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "VersionService.Version"
					return conn.Request(ctx, method, request, response)
				},
			},
			"KeepaliveStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(KeepaliveStreamRequest) },
				NewResponse:  func() proto.Message { return new(KeepaliveEvent) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(KeepaliveStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(KeepaliveEvent).ProtoReflect().Descriptor() },
				Help: "KeepaliveStream returns a stream where the server continuously writes keepalive events.\n" +
					"The stream only terminates if the client requests it or the connection to the server is closed.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(VersionServiceServer).KeepaliveStream(ctx, request.(*KeepaliveStreamRequest), streamerImpl[*KeepaliveEvent]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "VersionService.KeepaliveStream"
					return conn.Stream(ctx, method, request)
				},
			},
		},
	}
}

// ChatServiceClient is the client API for ChatService service.
type ChatServiceClient interface {
	// PM sends a private message to a user of the client.
	PM(ctx context.Context, in *PMRequest, out *PMResponse) error
	// PMStream returns a stream that gets PMs received by the client.
	PMStream(ctx context.Context, in *PMStreamRequest) (ChatService_PMStreamClient, error)
	// AckReceivedPM acks to the server that PMs up to a sequence ID have been
	// processed.
	AckReceivedPM(ctx context.Context, in *AckRequest, out *AckResponse) error
	// GCM sends a message in a GC.
	GCM(ctx context.Context, in *GCMRequest, out *GCMResponse) error
	// GCMStream returns a stream that gets GC messages received by the client.
	GCMStream(ctx context.Context, in *GCMStreamRequest) (ChatService_GCMStreamClient, error)
	// AckReceivedGCM acks to the server that GCMs up to a sequence ID have been
	// processed.
	AckReceivedGCM(ctx context.Context, in *AckRequest, out *AckResponse) error
	// MediateKX requests a transitive mediate KX with a mediator, towards a
	// target user.
	MediateKX(ctx context.Context, in *MediateKXRequest, out *MediateKXResponse) error
	// KXStream returns a stream that gets notifications of completed KXs. Both
	// new users and KXs resulting from a reset trigger a new event in this
	// stream.
	KXStream(ctx context.Context, in *KXStreamRequest) (ChatService_KXStreamClient, error)
	// AckKXCompleted acks to the server that KXs up to the sequence ID have been
	// processed.
	AckKXCompleted(ctx context.Context, in *AckRequest, out *AckResponse) error
	// WriteNewInvite writes an invite to be sent (out-of-band) to an user to
	// perform KX with.
	WriteNewInvite(ctx context.Context, in *WriteNewInviteRequest, out *WriteNewInviteResponse) error
	// AcceptInvite accepts an invite to kx with the user-provided invite.
	AcceptInvite(ctx context.Context, in *AcceptInviteRequest, out *AcceptInviteResponse) error
	// SendFile sends a file to a user.
	SendFile(ctx context.Context, in *SendFileRequest, out *SendFileResponse) error
}

type client_ChatService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_ChatService) PM(ctx context.Context, in *PMRequest, out *PMResponse) error {
	const method = "PM"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type ChatService_PMStreamClient interface {
	Recv(*ReceivedPM) error
}

func (c *client_ChatService) PMStream(ctx context.Context, in *PMStreamRequest) (ChatService_PMStreamClient, error) {
	const method = "PMStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*ReceivedPM]{c: inner}, nil
}

func (c *client_ChatService) AckReceivedPM(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckReceivedPM"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_ChatService) GCM(ctx context.Context, in *GCMRequest, out *GCMResponse) error {
	const method = "GCM"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type ChatService_GCMStreamClient interface {
	Recv(*GCReceivedMsg) error
}

func (c *client_ChatService) GCMStream(ctx context.Context, in *GCMStreamRequest) (ChatService_GCMStreamClient, error) {
	const method = "GCMStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*GCReceivedMsg]{c: inner}, nil
}

func (c *client_ChatService) AckReceivedGCM(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckReceivedGCM"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_ChatService) MediateKX(ctx context.Context, in *MediateKXRequest, out *MediateKXResponse) error {
	const method = "MediateKX"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type ChatService_KXStreamClient interface {
	Recv(*KXCompleted) error
}

func (c *client_ChatService) KXStream(ctx context.Context, in *KXStreamRequest) (ChatService_KXStreamClient, error) {
	const method = "KXStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*KXCompleted]{c: inner}, nil
}

func (c *client_ChatService) AckKXCompleted(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckKXCompleted"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_ChatService) WriteNewInvite(ctx context.Context, in *WriteNewInviteRequest, out *WriteNewInviteResponse) error {
	const method = "WriteNewInvite"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_ChatService) AcceptInvite(ctx context.Context, in *AcceptInviteRequest, out *AcceptInviteResponse) error {
	const method = "AcceptInvite"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_ChatService) SendFile(ctx context.Context, in *SendFileRequest, out *SendFileResponse) error {
	const method = "SendFile"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func NewChatServiceClient(c ClientConn) ChatServiceClient {
	return &client_ChatService{c: c, defn: ChatServiceDefn()}
}

// ChatServiceServer is the server API for ChatService service.
type ChatServiceServer interface {
	// PM sends a private message to a user of the client.
	PM(context.Context, *PMRequest, *PMResponse) error
	// PMStream returns a stream that gets PMs received by the client.
	PMStream(context.Context, *PMStreamRequest, ChatService_PMStreamServer) error
	// AckReceivedPM acks to the server that PMs up to a sequence ID have been
	// processed.
	AckReceivedPM(context.Context, *AckRequest, *AckResponse) error
	// GCM sends a message in a GC.
	GCM(context.Context, *GCMRequest, *GCMResponse) error
	// GCMStream returns a stream that gets GC messages received by the client.
	GCMStream(context.Context, *GCMStreamRequest, ChatService_GCMStreamServer) error
	// AckReceivedGCM acks to the server that GCMs up to a sequence ID have been
	// processed.
	AckReceivedGCM(context.Context, *AckRequest, *AckResponse) error
	// MediateKX requests a transitive mediate KX with a mediator, towards a
	// target user.
	MediateKX(context.Context, *MediateKXRequest, *MediateKXResponse) error
	// KXStream returns a stream that gets notifications of completed KXs. Both
	// new users and KXs resulting from a reset trigger a new event in this
	// stream.
	KXStream(context.Context, *KXStreamRequest, ChatService_KXStreamServer) error
	// AckKXCompleted acks to the server that KXs up to the sequence ID have been
	// processed.
	AckKXCompleted(context.Context, *AckRequest, *AckResponse) error
	// WriteNewInvite writes an invite to be sent (out-of-band) to an user to
	// perform KX with.
	WriteNewInvite(context.Context, *WriteNewInviteRequest, *WriteNewInviteResponse) error
	// AcceptInvite accepts an invite to kx with the user-provided invite.
	AcceptInvite(context.Context, *AcceptInviteRequest, *AcceptInviteResponse) error
	// SendFile sends a file to a user.
	SendFile(context.Context, *SendFileRequest, *SendFileResponse) error
}

type ChatService_PMStreamServer interface {
	Send(m *ReceivedPM) error
}

type ChatService_GCMStreamServer interface {
	Send(m *GCReceivedMsg) error
}

type ChatService_KXStreamServer interface {
	Send(m *KXCompleted) error
}

func ChatServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "ChatService",
		Methods: map[string]MethodDefn{
			"PM": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(PMRequest) },
				NewResponse:  func() proto.Message { return new(PMResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(PMRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(PMResponse).ProtoReflect().Descriptor() },
				Help:         "PM sends a private message to a user of the client.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).PM(ctx, request.(*PMRequest), response.(*PMResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.PM"
					return conn.Request(ctx, method, request, response)
				},
			},
			"PMStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(PMStreamRequest) },
				NewResponse:  func() proto.Message { return new(ReceivedPM) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(PMStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ReceivedPM).ProtoReflect().Descriptor() },
				Help:         "PMStream returns a stream that gets PMs received by the client.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(ChatServiceServer).PMStream(ctx, request.(*PMStreamRequest), streamerImpl[*ReceivedPM]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "ChatService.PMStream"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckReceivedPM": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckReceivedPM acks to the server that PMs up to a sequence ID have been processed.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).AckReceivedPM(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.AckReceivedPM"
					return conn.Request(ctx, method, request, response)
				},
			},
			"GCM": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(GCMRequest) },
				NewResponse:  func() proto.Message { return new(GCMResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(GCMRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(GCMResponse).ProtoReflect().Descriptor() },
				Help:         "GCM sends a message in a GC.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).GCM(ctx, request.(*GCMRequest), response.(*GCMResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.GCM"
					return conn.Request(ctx, method, request, response)
				},
			},
			"GCMStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(GCMStreamRequest) },
				NewResponse:  func() proto.Message { return new(GCReceivedMsg) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(GCMStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(GCReceivedMsg).ProtoReflect().Descriptor() },
				Help:         "GCMStream returns a stream that gets GC messages received by the client.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(ChatServiceServer).GCMStream(ctx, request.(*GCMStreamRequest), streamerImpl[*GCReceivedMsg]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "ChatService.GCMStream"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckReceivedGCM": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckReceivedGCM acks to the server that GCMs up to a sequence ID have been processed.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).AckReceivedGCM(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.AckReceivedGCM"
					return conn.Request(ctx, method, request, response)
				},
			},
			"MediateKX": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(MediateKXRequest) },
				NewResponse:  func() proto.Message { return new(MediateKXResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(MediateKXRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(MediateKXResponse).ProtoReflect().Descriptor() },
				Help:         "MediateKX requests a transitive mediate KX with a mediator, towards a target user.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).MediateKX(ctx, request.(*MediateKXRequest), response.(*MediateKXResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.MediateKX"
					return conn.Request(ctx, method, request, response)
				},
			},
			"KXStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(KXStreamRequest) },
				NewResponse:  func() proto.Message { return new(KXCompleted) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(KXStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(KXCompleted).ProtoReflect().Descriptor() },
				Help:         "KXStream returns a stream that gets notifications of completed KXs. Both new users and KXs resulting from a reset trigger a new event in this stream.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(ChatServiceServer).KXStream(ctx, request.(*KXStreamRequest), streamerImpl[*KXCompleted]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "ChatService.KXStream"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckKXCompleted": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckKXCompleted acks to the server that KXs up to the sequence ID have been processed.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).AckKXCompleted(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.AckKXCompleted"
					return conn.Request(ctx, method, request, response)
				},
			},
			"WriteNewInvite": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(WriteNewInviteRequest) },
				NewResponse:  func() proto.Message { return new(WriteNewInviteResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(WriteNewInviteRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(WriteNewInviteResponse).ProtoReflect().Descriptor() },
				Help:         "WriteNewInvite writes an invite to be sent (out-of-band) to an user to perform KX with.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).WriteNewInvite(ctx, request.(*WriteNewInviteRequest), response.(*WriteNewInviteResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.WriteNewInvite"
					return conn.Request(ctx, method, request, response)
				},
			},
			"AcceptInvite": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AcceptInviteRequest) },
				NewResponse:  func() proto.Message { return new(AcceptInviteResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AcceptInviteRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AcceptInviteResponse).ProtoReflect().Descriptor() },
				Help:         "AcceptInvite accepts an invite to kx with the user-provided invite.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).AcceptInvite(ctx, request.(*AcceptInviteRequest), response.(*AcceptInviteResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.AcceptInvite"
					return conn.Request(ctx, method, request, response)
				},
			},
			"SendFile": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(SendFileRequest) },
				NewResponse:  func() proto.Message { return new(SendFileResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(SendFileRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(SendFileResponse).ProtoReflect().Descriptor() },
				Help:         "SendFile sends a file to a user.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).SendFile(ctx, request.(*SendFileRequest), response.(*SendFileResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.SendFile"
					return conn.Request(ctx, method, request, response)
				},
			},
		},
	}
}

// GCServiceClient is the client API for GCService service.
type GCServiceClient interface {
	// InviteToGC invites an user to join a GC. The local user must have admin
	// privileges in the gc.
	InviteToGC(ctx context.Context, in *InviteToGCRequest, out *InviteToGCResponse) error
	// AcceptGCInvite accepts an invitation to join a GC.
	AcceptGCInvite(ctx context.Context, in *AcceptGCInviteRequest, out *AcceptGCInviteResponse) error
	// KickFromGC kicks an user from a GC. The local user must have admin
	// privileges in the GC.
	KickFromGC(ctx context.Context, in *KickFromGCRequest, out *KickFromGCResponse) error
	// GetGC returns the full definition for a GC.
	GetGC(ctx context.Context, in *GetGCRequest, out *GetGCResponse) error
	// List returns a list with all GCs.
	List(ctx context.Context, in *ListGCsRequest, out *ListGCsResponse) error
	// ReceivedGCInvites returns a stream that gets sent invitations that remote
	// users make for the local client to join GCs.
	ReceivedGCInvites(ctx context.Context, in *ReceivedGCInvitesRequest) (GCService_ReceivedGCInvitesClient, error)
	// AckReceivedGCInvites acks received gc invite events.
	AckReceivedGCInvites(ctx context.Context, in *AckRequest, out *AckResponse) error
	// MembersAdded returns a stream that gets sent events about members added
	// to GCs the local client participates in.
	MembersAdded(ctx context.Context, in *GCMembersAddedRequest) (GCService_MembersAddedClient, error)
	// AckMembersAdded acks received members added events.
	AckMembersAdded(ctx context.Context, in *AckRequest, out *AckResponse) error
	// MembersRemoved returns a stream that gets sent events about members removed
	// from GCs the local client participates in.
	MembersRemoved(ctx context.Context, in *GCMembersRemovedRequest) (GCService_MembersRemovedClient, error)
	// AckMembersRemoved acks received members removed events.
	AckMembersRemoved(ctx context.Context, in *AckRequest, out *AckResponse) error
	// JoinedGCs returns a stream that gets sent events about GCs the local client
	// has joined.
	JoinedGCs(ctx context.Context, in *JoinedGCsRequest) (GCService_JoinedGCsClient, error)
	// AckJoinedGCs acks received joined gc events.
	AckJoinedGCs(ctx context.Context, in *AckRequest, out *AckResponse) error
}

type client_GCService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_GCService) InviteToGC(ctx context.Context, in *InviteToGCRequest, out *InviteToGCResponse) error {
	const method = "InviteToGC"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_GCService) AcceptGCInvite(ctx context.Context, in *AcceptGCInviteRequest, out *AcceptGCInviteResponse) error {
	const method = "AcceptGCInvite"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_GCService) KickFromGC(ctx context.Context, in *KickFromGCRequest, out *KickFromGCResponse) error {
	const method = "KickFromGC"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_GCService) GetGC(ctx context.Context, in *GetGCRequest, out *GetGCResponse) error {
	const method = "GetGC"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_GCService) List(ctx context.Context, in *ListGCsRequest, out *ListGCsResponse) error {
	const method = "List"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type GCService_ReceivedGCInvitesClient interface {
	Recv(*ReceivedGCInvite) error
}

func (c *client_GCService) ReceivedGCInvites(ctx context.Context, in *ReceivedGCInvitesRequest) (GCService_ReceivedGCInvitesClient, error) {
	const method = "ReceivedGCInvites"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*ReceivedGCInvite]{c: inner}, nil
}

func (c *client_GCService) AckReceivedGCInvites(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckReceivedGCInvites"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type GCService_MembersAddedClient interface {
	Recv(*GCMembersAddedEvent) error
}

func (c *client_GCService) MembersAdded(ctx context.Context, in *GCMembersAddedRequest) (GCService_MembersAddedClient, error) {
	const method = "MembersAdded"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*GCMembersAddedEvent]{c: inner}, nil
}

func (c *client_GCService) AckMembersAdded(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckMembersAdded"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type GCService_MembersRemovedClient interface {
	Recv(*GCMembersRemovedEvent) error
}

func (c *client_GCService) MembersRemoved(ctx context.Context, in *GCMembersRemovedRequest) (GCService_MembersRemovedClient, error) {
	const method = "MembersRemoved"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*GCMembersRemovedEvent]{c: inner}, nil
}

func (c *client_GCService) AckMembersRemoved(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckMembersRemoved"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type GCService_JoinedGCsClient interface {
	Recv(*JoinedGCEvent) error
}

func (c *client_GCService) JoinedGCs(ctx context.Context, in *JoinedGCsRequest) (GCService_JoinedGCsClient, error) {
	const method = "JoinedGCs"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*JoinedGCEvent]{c: inner}, nil
}

func (c *client_GCService) AckJoinedGCs(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckJoinedGCs"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func NewGCServiceClient(c ClientConn) GCServiceClient {
	return &client_GCService{c: c, defn: GCServiceDefn()}
}

// GCServiceServer is the server API for GCService service.
type GCServiceServer interface {
	// InviteToGC invites an user to join a GC. The local user must have admin
	// privileges in the gc.
	InviteToGC(context.Context, *InviteToGCRequest, *InviteToGCResponse) error
	// AcceptGCInvite accepts an invitation to join a GC.
	AcceptGCInvite(context.Context, *AcceptGCInviteRequest, *AcceptGCInviteResponse) error
	// KickFromGC kicks an user from a GC. The local user must have admin
	// privileges in the GC.
	KickFromGC(context.Context, *KickFromGCRequest, *KickFromGCResponse) error
	// GetGC returns the full definition for a GC.
	GetGC(context.Context, *GetGCRequest, *GetGCResponse) error
	// List returns a list with all GCs.
	List(context.Context, *ListGCsRequest, *ListGCsResponse) error
	// ReceivedGCInvites returns a stream that gets sent invitations that remote
	// users make for the local client to join GCs.
	ReceivedGCInvites(context.Context, *ReceivedGCInvitesRequest, GCService_ReceivedGCInvitesServer) error
	// AckReceivedGCInvites acks received gc invite events.
	AckReceivedGCInvites(context.Context, *AckRequest, *AckResponse) error
	// MembersAdded returns a stream that gets sent events about members added
	// to GCs the local client participates in.
	MembersAdded(context.Context, *GCMembersAddedRequest, GCService_MembersAddedServer) error
	// AckMembersAdded acks received members added events.
	AckMembersAdded(context.Context, *AckRequest, *AckResponse) error
	// MembersRemoved returns a stream that gets sent events about members removed
	// from GCs the local client participates in.
	MembersRemoved(context.Context, *GCMembersRemovedRequest, GCService_MembersRemovedServer) error
	// AckMembersRemoved acks received members removed events.
	AckMembersRemoved(context.Context, *AckRequest, *AckResponse) error
	// JoinedGCs returns a stream that gets sent events about GCs the local client
	// has joined.
	JoinedGCs(context.Context, *JoinedGCsRequest, GCService_JoinedGCsServer) error
	// AckJoinedGCs acks received joined gc events.
	AckJoinedGCs(context.Context, *AckRequest, *AckResponse) error
}

type GCService_ReceivedGCInvitesServer interface {
	Send(m *ReceivedGCInvite) error
}

type GCService_MembersAddedServer interface {
	Send(m *GCMembersAddedEvent) error
}

type GCService_MembersRemovedServer interface {
	Send(m *GCMembersRemovedEvent) error
}

type GCService_JoinedGCsServer interface {
	Send(m *JoinedGCEvent) error
}

func GCServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "GCService",
		Methods: map[string]MethodDefn{
			"InviteToGC": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(InviteToGCRequest) },
				NewResponse:  func() proto.Message { return new(InviteToGCResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(InviteToGCRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(InviteToGCResponse).ProtoReflect().Descriptor() },
				Help:         "InviteToGC invites an user to join a GC. The local user must have admin privileges in the gc.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).InviteToGC(ctx, request.(*InviteToGCRequest), response.(*InviteToGCResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.InviteToGC"
					return conn.Request(ctx, method, request, response)
				},
			},
			"AcceptGCInvite": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AcceptGCInviteRequest) },
				NewResponse:  func() proto.Message { return new(AcceptGCInviteResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AcceptGCInviteRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AcceptGCInviteResponse).ProtoReflect().Descriptor() },
				Help:         "AcceptGCInvite accepts an invitation to join a GC.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).AcceptGCInvite(ctx, request.(*AcceptGCInviteRequest), response.(*AcceptGCInviteResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.AcceptGCInvite"
					return conn.Request(ctx, method, request, response)
				},
			},
			"KickFromGC": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(KickFromGCRequest) },
				NewResponse:  func() proto.Message { return new(KickFromGCResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(KickFromGCRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(KickFromGCResponse).ProtoReflect().Descriptor() },
				Help:         "KickFromGC kicks an user from a GC. The local user must have admin privileges in the GC.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).KickFromGC(ctx, request.(*KickFromGCRequest), response.(*KickFromGCResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.KickFromGC"
					return conn.Request(ctx, method, request, response)
				},
			},
			"GetGC": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(GetGCRequest) },
				NewResponse:  func() proto.Message { return new(GetGCResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(GetGCRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(GetGCResponse).ProtoReflect().Descriptor() },
				Help:         "GetGC returns the full definition for a GC.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).GetGC(ctx, request.(*GetGCRequest), response.(*GetGCResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.GetGC"
					return conn.Request(ctx, method, request, response)
				},
			},
			"List": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(ListGCsRequest) },
				NewResponse:  func() proto.Message { return new(ListGCsResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(ListGCsRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ListGCsResponse).ProtoReflect().Descriptor() },
				Help:         "List returns a list with all GCs.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).List(ctx, request.(*ListGCsRequest), response.(*ListGCsResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.List"
					return conn.Request(ctx, method, request, response)
				},
			},
			"ReceivedGCInvites": {
				IsStreaming: true,
				NewRequest:  func() proto.Message { return new(ReceivedGCInvitesRequest) },
				NewResponse: func() proto.Message { return new(ReceivedGCInvite) },
				RequestDefn: func() protoreflect.MessageDescriptor {
					return new(ReceivedGCInvitesRequest).ProtoReflect().Descriptor()
				},
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ReceivedGCInvite).ProtoReflect().Descriptor() },
				Help:         "ReceivedGCInvites returns a stream that gets sent invitations that remote users make for the local client to join GCs.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(GCServiceServer).ReceivedGCInvites(ctx, request.(*ReceivedGCInvitesRequest), streamerImpl[*ReceivedGCInvite]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "GCService.ReceivedGCInvites"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckReceivedGCInvites": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckReceivedGCInvites acks received gc invite events.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).AckReceivedGCInvites(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.AckReceivedGCInvites"
					return conn.Request(ctx, method, request, response)
				},
			},
			"MembersAdded": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(GCMembersAddedRequest) },
				NewResponse:  func() proto.Message { return new(GCMembersAddedEvent) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(GCMembersAddedRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(GCMembersAddedEvent).ProtoReflect().Descriptor() },
				Help:         "MembersAdded returns a stream that gets sent events about members added to GCs the local client participates in.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(GCServiceServer).MembersAdded(ctx, request.(*GCMembersAddedRequest), streamerImpl[*GCMembersAddedEvent]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "GCService.MembersAdded"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckMembersAdded": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckMembersAdded acks received members added events.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).AckMembersAdded(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.AckMembersAdded"
					return conn.Request(ctx, method, request, response)
				},
			},
			"MembersRemoved": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(GCMembersRemovedRequest) },
				NewResponse:  func() proto.Message { return new(GCMembersRemovedEvent) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(GCMembersRemovedRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(GCMembersRemovedEvent).ProtoReflect().Descriptor() },
				Help:         "MembersRemoved returns a stream that gets sent events about members removed from GCs the local client participates in.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(GCServiceServer).MembersRemoved(ctx, request.(*GCMembersRemovedRequest), streamerImpl[*GCMembersRemovedEvent]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "GCService.MembersRemoved"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckMembersRemoved": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckMembersRemoved acks received members removed events.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).AckMembersRemoved(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.AckMembersRemoved"
					return conn.Request(ctx, method, request, response)
				},
			},
			"JoinedGCs": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(JoinedGCsRequest) },
				NewResponse:  func() proto.Message { return new(JoinedGCEvent) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(JoinedGCsRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(JoinedGCEvent).ProtoReflect().Descriptor() },
				Help:         "JoinedGCs returns a stream that gets sent events about GCs the local client has joined.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(GCServiceServer).JoinedGCs(ctx, request.(*JoinedGCsRequest), streamerImpl[*JoinedGCEvent]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "GCService.JoinedGCs"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckJoinedGCs": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckJoinedGCs acks received joined gc events.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(GCServiceServer).AckJoinedGCs(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "GCService.AckJoinedGCs"
					return conn.Request(ctx, method, request, response)
				},
			},
		},
	}
}

// PostsServiceClient is the client API for PostsService service.
type PostsServiceClient interface {
	// SubscribeToPosts makes the local client subscribe to a remote user's posts.
	SubscribeToPosts(ctx context.Context, in *SubscribeToPostsRequest, out *SubscribeToPostsResponse) error
	// UnsubscribeToPosts makes the local client unsubscribe from a remote user's posts.
	UnsubscribeToPosts(ctx context.Context, in *UnsubscribeToPostsRequest, out *UnsubscribeToPostsResponse) error
	// PostsStream creates a stream that receives updates about posts received
	// from remote users the local client is subscribed to.
	PostsStream(ctx context.Context, in *PostsStreamRequest) (PostsService_PostsStreamClient, error)
	// AckReceivedPost acknowledges posts received up to a given sequence_id have
	// been processed.
	AckReceivedPost(ctx context.Context, in *AckRequest, out *AckResponse) error
	// PostsStatusStream creates a stream that receives updates about post status
	// events (comments, replies, etc).
	PostsStatusStream(ctx context.Context, in *PostsStatusStreamRequest) (PostsService_PostsStatusStreamClient, error)
	// AckReceivedPostStatus acknowledges post status received up to a given
	// sequence_id have been processed.
	AckReceivedPostStatus(ctx context.Context, in *AckRequest, out *AckResponse) error
}

type client_PostsService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_PostsService) SubscribeToPosts(ctx context.Context, in *SubscribeToPostsRequest, out *SubscribeToPostsResponse) error {
	const method = "SubscribeToPosts"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func (c *client_PostsService) UnsubscribeToPosts(ctx context.Context, in *UnsubscribeToPostsRequest, out *UnsubscribeToPostsResponse) error {
	const method = "UnsubscribeToPosts"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type PostsService_PostsStreamClient interface {
	Recv(*ReceivedPost) error
}

func (c *client_PostsService) PostsStream(ctx context.Context, in *PostsStreamRequest) (PostsService_PostsStreamClient, error) {
	const method = "PostsStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*ReceivedPost]{c: inner}, nil
}

func (c *client_PostsService) AckReceivedPost(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckReceivedPost"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type PostsService_PostsStatusStreamClient interface {
	Recv(*ReceivedPostStatus) error
}

func (c *client_PostsService) PostsStatusStream(ctx context.Context, in *PostsStatusStreamRequest) (PostsService_PostsStatusStreamClient, error) {
	const method = "PostsStatusStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*ReceivedPostStatus]{c: inner}, nil
}

func (c *client_PostsService) AckReceivedPostStatus(ctx context.Context, in *AckRequest, out *AckResponse) error {
	const method = "AckReceivedPostStatus"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func NewPostsServiceClient(c ClientConn) PostsServiceClient {
	return &client_PostsService{c: c, defn: PostsServiceDefn()}
}

// PostsServiceServer is the server API for PostsService service.
type PostsServiceServer interface {
	// SubscribeToPosts makes the local client subscribe to a remote user's posts.
	SubscribeToPosts(context.Context, *SubscribeToPostsRequest, *SubscribeToPostsResponse) error
	// UnsubscribeToPosts makes the local client unsubscribe from a remote user's posts.
	UnsubscribeToPosts(context.Context, *UnsubscribeToPostsRequest, *UnsubscribeToPostsResponse) error
	// PostsStream creates a stream that receives updates about posts received
	// from remote users the local client is subscribed to.
	PostsStream(context.Context, *PostsStreamRequest, PostsService_PostsStreamServer) error
	// AckReceivedPost acknowledges posts received up to a given sequence_id have
	// been processed.
	AckReceivedPost(context.Context, *AckRequest, *AckResponse) error
	// PostsStatusStream creates a stream that receives updates about post status
	// events (comments, replies, etc).
	PostsStatusStream(context.Context, *PostsStatusStreamRequest, PostsService_PostsStatusStreamServer) error
	// AckReceivedPostStatus acknowledges post status received up to a given
	// sequence_id have been processed.
	AckReceivedPostStatus(context.Context, *AckRequest, *AckResponse) error
}

type PostsService_PostsStreamServer interface {
	Send(m *ReceivedPost) error
}

type PostsService_PostsStatusStreamServer interface {
	Send(m *ReceivedPostStatus) error
}

func PostsServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "PostsService",
		Methods: map[string]MethodDefn{
			"SubscribeToPosts": {
				IsStreaming: false,
				NewRequest:  func() proto.Message { return new(SubscribeToPostsRequest) },
				NewResponse: func() proto.Message { return new(SubscribeToPostsResponse) },
				RequestDefn: func() protoreflect.MessageDescriptor { return new(SubscribeToPostsRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor {
					return new(SubscribeToPostsResponse).ProtoReflect().Descriptor()
				},
				Help: "SubscribeToPosts makes the local client subscribe to a remote user's posts.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(PostsServiceServer).SubscribeToPosts(ctx, request.(*SubscribeToPostsRequest), response.(*SubscribeToPostsResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "PostsService.SubscribeToPosts"
					return conn.Request(ctx, method, request, response)
				},
			},
			"UnsubscribeToPosts": {
				IsStreaming: false,
				NewRequest:  func() proto.Message { return new(UnsubscribeToPostsRequest) },
				NewResponse: func() proto.Message { return new(UnsubscribeToPostsResponse) },
				RequestDefn: func() protoreflect.MessageDescriptor {
					return new(UnsubscribeToPostsRequest).ProtoReflect().Descriptor()
				},
				ResponseDefn: func() protoreflect.MessageDescriptor {
					return new(UnsubscribeToPostsResponse).ProtoReflect().Descriptor()
				},
				Help: "UnsubscribeToPosts makes the local client unsubscribe from a remote user's posts.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(PostsServiceServer).UnsubscribeToPosts(ctx, request.(*UnsubscribeToPostsRequest), response.(*UnsubscribeToPostsResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "PostsService.UnsubscribeToPosts"
					return conn.Request(ctx, method, request, response)
				},
			},
			"PostsStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(PostsStreamRequest) },
				NewResponse:  func() proto.Message { return new(ReceivedPost) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(PostsStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ReceivedPost).ProtoReflect().Descriptor() },
				Help:         "PostsStream creates a stream that receives updates about posts received from remote users the local client is subscribed to.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(PostsServiceServer).PostsStream(ctx, request.(*PostsStreamRequest), streamerImpl[*ReceivedPost]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "PostsService.PostsStream"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckReceivedPost": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckReceivedPost acknowledges posts received up to a given sequence_id have been processed.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(PostsServiceServer).AckReceivedPost(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "PostsService.AckReceivedPost"
					return conn.Request(ctx, method, request, response)
				},
			},
			"PostsStatusStream": {
				IsStreaming: true,
				NewRequest:  func() proto.Message { return new(PostsStatusStreamRequest) },
				NewResponse: func() proto.Message { return new(ReceivedPostStatus) },
				RequestDefn: func() protoreflect.MessageDescriptor {
					return new(PostsStatusStreamRequest).ProtoReflect().Descriptor()
				},
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ReceivedPostStatus).ProtoReflect().Descriptor() },
				Help:         "PostsStatusStream creates a stream that receives updates about post status events (comments, replies, etc).",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(PostsServiceServer).PostsStatusStream(ctx, request.(*PostsStatusStreamRequest), streamerImpl[*ReceivedPostStatus]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "PostsService.PostsStatusStream"
					return conn.Stream(ctx, method, request)
				},
			},
			"AckReceivedPostStatus": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(AckRequest) },
				NewResponse:  func() proto.Message { return new(AckResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(AckRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(AckResponse).ProtoReflect().Descriptor() },
				Help:         "AckReceivedPostStatus acknowledges post status received up to a given sequence_id have been processed.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(PostsServiceServer).AckReceivedPostStatus(ctx, request.(*AckRequest), response.(*AckResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "PostsService.AckReceivedPostStatus"
					return conn.Request(ctx, method, request, response)
				},
			},
		},
	}
}

// PaymentsServiceClient is the client API for PaymentsService service.
type PaymentsServiceClient interface {
	// TipUser attempts to send a tip to a user. The user must be or come online
	// for this to complete.
	TipUser(ctx context.Context, in *TipUserRequest, out *TipUserResponse) error
}

type client_PaymentsService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_PaymentsService) TipUser(ctx context.Context, in *TipUserRequest, out *TipUserResponse) error {
	const method = "TipUser"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

func NewPaymentsServiceClient(c ClientConn) PaymentsServiceClient {
	return &client_PaymentsService{c: c, defn: PaymentsServiceDefn()}
}

// PaymentsServiceServer is the server API for PaymentsService service.
type PaymentsServiceServer interface {
	// TipUser attempts to send a tip to a user. The user must be or come online
	// for this to complete.
	TipUser(context.Context, *TipUserRequest, *TipUserResponse) error
}

func PaymentsServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "PaymentsService",
		Methods: map[string]MethodDefn{
			"TipUser": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(TipUserRequest) },
				NewResponse:  func() proto.Message { return new(TipUserResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(TipUserRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(TipUserResponse).ProtoReflect().Descriptor() },
				Help:         "TipUser attempts to send a tip to a user. The user must be or come online for this to complete.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(PaymentsServiceServer).TipUser(ctx, request.(*TipUserRequest), response.(*TipUserResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "PaymentsService.TipUser"
					return conn.Request(ctx, method, request, response)
				},
			},
		},
	}
}

var help_messages = map[string]map[string]string{
	"VersionRequest": {
		"@": "",
	},
	"VersionResponse": {
		"@":           "VersionResponse is the information about the running RPC server.",
		"app_version": "app_version is the version of the application.",
		"go_runtime":  "go_runtime is the Go version the server was compiled with.",
		"app_name":    "app_name is the name of the underlying app running the server.",
	},
	"KeepaliveStreamRequest": {
		"@": "KeepaliveStreamRequest is the request for a new keepalive stream.",
		"interval": "interval is how often to send the keepalive (in milliseconds).\n" +
			"A minimum of 1 second is imposed, regardless of the value passed as interval.",
	},
	"KeepaliveEvent": {
		"@":         "KeepaliveEvent is a single keepalive event.",
		"timestamp": "timestamp is the unix timestamp on the server, with second precision.",
	},
	"AckRequest": {
		"@":           "AckRequest is a request to ack that a type of message up to a sequence ID has been processed.",
		"sequence_id": "sequence_id is the ID up to which messages have been processed.",
	},
	"AckResponse": {
		"@": "AckResponse is the response to an ack request.",
	},
	"PMRequest": {
		"@":    "PMRequest is a request to send a new private message.",
		"user": "user is either the nick, alias or an hex-encoded user ID of the destination.",
		"msg":  "msg is the message to be sent.",
	},
	"PMResponse": {
		"@": "PMResponse is the response of the client for a new message.",
	},
	"PMStreamRequest": {
		"@":            "PMStreamRequest is the request for a new private message reception stream.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last processed PM. PMs received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"ReceivedPM": {
		"@":            "ReceivedPM is a private message received by the client.",
		"uid":          "uid is the source user ID in raw format.",
		"nick":         "nick is the source's nick or alias.",
		"msg":          "msg is the received message payload.",
		"timestamp_ms": "timestamp_ms is the timestamp from unix epoch with millisecond precision.",
		"sequence_id":  "sequence_id is an opaque sequential ID.",
	},
	"GCMRequest": {
		"@":   "GCMRequest is a request to send a GC message.",
		"gc":  "gc is either an hex-encoded GCID or a GC alias.",
		"msg": "msg is the text payload of the message.",
	},
	"GCMResponse": {
		"@": "GCMResponse is the response to sending a GC message.",
	},
	"GCMStreamRequest": {
		"@":            "GCMStreamRequest is a request to a stream of received GC messages.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last processed GCM. GCMs received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"GCReceivedMsg": {
		"@":            "GCReceivedMsg is a GC message received from a remote user.",
		"uid":          "uid is the source user ID.",
		"nick":         "nick is the source user nick/alias.",
		"gc_alias":     "gc_alias is the local alias of the GC where the message was sent.",
		"msg":          "msg is the received message.",
		"timestamp_ms": "timestamp_ms is the server timestamp of the message with millisecond precision.",
		"sequence_id":  "sequence_id is an opaque sequential ID.",
	},
	"SubscribeToPostsRequest": {
		"@":    "SubscribeToPostsRequest is a request to subscribe to a remote user's posts.",
		"user": "user is the nick or hex-encoded ID of the user to subscribe to.",
	},
	"SubscribeToPostsResponse": {
		"@": "SubscribeToPostsResponse is the response to subscribing to a remote user's posts.",
	},
	"UnsubscribeToPostsRequest": {
		"@":    "UnsubscribeToPostsRequest is a request to unsubscribe from a remote user's posts.",
		"user": "user is the nick or hex-encoded ID of the user to unsubscribe from.",
	},
	"UnsubscribeToPostsResponse": {
		"@": "UnsubscribeToPostsResponse is the response to an unsubscribe request.",
	},
	"PostSummary": {
		"@":              "PostSummary is the summary information about a post.",
		"id":             "id is the post ID (hash of the post metadata).",
		"from":           "from is the id of the relayer of the post (who the local client received the post from).",
		"author_id":      "author_id is the id of the author of the post.",
		"author_nick":    "author_nick is the reported nick of the author of the post.",
		"date":           "date is the unix timestamp of the post.",
		"last_status_ts": "last_status_ts is the timestamp of the last recorded status update of the post.",
		"title":          "title is either the included or suggested title of the post.",
	},
	"PostsStreamRequest": {
		"@":            "PostsStreamRequest is the request to establish a stream of received post events.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last processed post. Posts received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"ReceivedPost": {
		"@":           "ReceivedPost is a post received by the local client.",
		"sequence_id": "sequence_id is an opaque sequential ID.",
		"relayer_id":  "relayer_id is the id of the user we received the post from (may not be the same as the author).",
		"summary":     "summary is the summary information about the post.",
		"post":        "post is the full post data.",
	},
	"PostsStatusStreamRequest": {
		"@":            "PostsStatusStreamRequest is a request to establish a stream that receives post status updates received by the local client.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last processed Post Status. Post Status received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"ReceivedPostStatus": {
		"@":                "ReceivedPostStatus is a post status update received by the local client.",
		"sequence_id":      "sequence_id is an opaque sequential ID.",
		"relayer_id":       "relayer_id is the id of the sender of the client that sent the update.",
		"post_id":          "post_id is the id of the corresponding post.",
		"status_from":      "status_from is the original author of the status.",
		"status":           "status is the full status data.",
		"status_from_nick": "status_from_nick is the nick of the original author of the status.",
	},
	"TipUserRequest": {
		"@":            "TipUserRequest is a request to tip a remote user.",
		"user":         "user is the remote user nick or hex-encoded ID.",
		"dcr_amount":   "dcr_amount is the DCR amount to send as tip.",
		"max_attempts": "max_attempts is the number of max attempts to try to send the tip.",
	},
	"TipUserResponse": {
		"@": "TipUserResponse is the response to a tip user request.",
	},
	"MediateKXRequest": {
		"@":        "MediateKXRequest is the request to perform a transitive KX with a given user.",
		"mediator": "mediator is the nick or hex ID of the mediator user (which must already be KX'd with).",
		"target":   "target is the hex ID of the target user to KX with.",
	},
	"MediateKXResponse": {
		"@": "MediateKXResponse is the response to a mediate KX request.",
	},
	"KXStreamRequest": {
		"@":            "KXStreamRequest is the request sent when obtaining a stream of KX notifications.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last completed KX. KXs completed by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"KXCompleted": {
		"@":                  "KXCompleted is the information about a completed KX event.",
		"sequence_id":        "sequence_id is an opaque sequential ID.",
		"uid":                "uid is the raw ID of the KX'd user.",
		"nick":               "nick is the nick of the KX'd user.",
		"initial_rendezvous": "initial_rendezvous is the initial random RV the key exchange happened.",
	},
	"WriteNewInviteRequest": {
		"@": "WriteNewInviteRequest is the request to add a new invite.",
	},
	"WriteNewInviteResponse": {
		"@":            "WriteNewInviteResponse is an invite that can be sent (out-of-band) to an user the local client wishes to KX with.",
		"invite_bytes": "invite_bytes is the raw invite.",
		"invite":       "invite is the data contained in the raw invite.",
	},
	"AcceptInviteRequest": {
		"@":            "AcceptInviteRequest is the request to accept an invite to KX with an user.",
		"invite_bytes": "invite_bytes is the raw invite.",
	},
	"AcceptInviteResponse": {
		"@":      "AcceptInviteResponse is the response to accepting an invite to KX with an user.",
		"invite": "invite is the decoded invite accepted.",
	},
	"InviteToGCRequest": {
		"@":    "InviteToGCRequest is the request to invite an user to a GC.",
		"gc":   "gc is the hex-encoded ID or the alias of the GC in the local client.",
		"user": "user is the hex-encoded ID of the user or its nick.",
	},
	"InviteToGCResponse": {
		"@": "InviteToGCResponse is the response to the request to invite an user to a GC.",
	},
	"AcceptGCInviteRequest": {
		"@":         "AcceptGCInviteRequest is the request to accept an invite to join a GC.",
		"invite_id": "invite_id is the id to use to join the invite.",
	},
	"AcceptGCInviteResponse": {
		"@": "AcceptGCInviteResponse is the response to accept an invite to join a GC.",
	},
	"SendFileRequest": {
		"@":        "SendFileRequest is the request to send a file to a user.",
		"user":     "user is the hex-encoded ID of the user or its nick.",
		"filename": "filename is the absolute path to the file.",
	},
	"SendFileResponse": {
		"@": "SendFileResponse is the response to sending a file to a user.",
	},
	"KickFromGCRequest": {
		"@":      "KickFromGCRequest is the request to kick an user from a GC.",
		"gc":     "gc is the hex-encoded ID or alias of the target GC.",
		"user":   "user is the hex-encoded ID or nick of the target user.",
		"reason": "reason is an optional reason to send for the kick.",
	},
	"KickFromGCResponse": {
		"@": "KickFromGCResponse is the response to a kick request.",
	},
	"GetGCRequest": {
		"@":  "GetGCRequest is the request to get GC datails.",
		"gc": "gc is the hex-encoded ID or alias of the target GC.",
	},
	"GetGCResponse": {
		"@":  "GetGCResponse is the response to a request to get GC details.",
		"gc": "gc is the gc definition.",
	},
	"ListGCsRequest": {
		"@": "ListGCsRequest is the request to list GC data.",
	},
	"ListGCsResponse": {
		"@":   "ListGCsResponse is the response to a request to list GC data.",
		"gcs": "gcs is the list of GCs for the local client.",
	},
	"ReceivedGCInvitesRequest": {
		"@":            "ReceivedGCInvitesRequest is the request to start receiving GC invite events.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last received GC invite. Invites received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"ReceivedGCInvite": {
		"@":            "ReceivedGCInvite is the event sent when an invitation to join a GC is received.",
		"sequence_id":  "sequence_id is an opaque sequential ID.",
		"inviter_uid":  "inviter_uid is the UID of the user that sent the invitation.",
		"inviter_nick": "inviter_nick is the nick of the user that sent the invitation.",
		"invite_id":    "invite_id is the unique invite ID that must be spcecified when accepting the invitation.",
		"invite":       "invite is the invite information.",
	},
	"UserAndNick": {
		"@":     "UserAndNick groups users and nicks when used in lists.",
		"uid":   "uid is the unique user ID.",
		"nick":  "nick is the local alias or nick of the user.",
		"known": "known flags whether the local client is KX'd with this user.",
	},
	"GCMembersAddedRequest": {
		"@":            "GCMembersAddedRequest is the request sent to create a stream that receives GC members added events.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last received GC members added event. Events received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"GCMembersAddedEvent": {
		"@":           "GCMembersAddedEvent are events received when a GC has new members.",
		"sequence_id": "sequence_id is an opaque sequential ID.",
		"gc":          "gc is the ID of the GC.",
		"gc_name":     "gc_name is the local alias of the GC.",
		"users":       "users is the list of users added to the GC.",
	},
	"GCMembersRemovedRequest": {
		"@":            "GCMembersRemovedRequest is the request to create a stream to receive GC members removed events.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last received GC members removed event. Events received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"GCMembersRemovedEvent": {
		"@":           "GCMembersRemovedEvent is an event received when members are removed from a GC.",
		"sequence_id": "sequence_id is an opaque sequential ID.",
		"gc":          "gc is the ID of the GC.",
		"gc_name":     "gc_name is the local alias of the GC.",
		"users":       "users is the list of users removed from the GC.",
	},
	"JoinedGCsRequest": {
		"@":            "JoinedGCsRequest is the request to create a stream that receives events about GCs the local client has joined.",
		"unacked_from": "unacked_from specifies to the server the sequence_id of the last received GC joined event. Events received by the server that have a higher sequence_id will be streamed back to the client.",
	},
	"JoinedGCEvent": {
		"@":           "JoinedGCEvent is the event received when the local client joins a GC.",
		"sequence_id": "sequence_id is an opaque sequential ID.",
		"gc":          "gc is the GC definition.",
	},
	"RMPrivateMessage": {
		"@":       "RMPrivateMessage is the network-level routed private message.",
		"message": "message is the private message payload.",
		"mode":    "mode is the message mode.",
	},
	"RMGroupMessage": {
		"@":          "RMGroupMessage is the network-level routed group message.",
		"id":         "id is the group chat id where the message was sent.",
		"generation": "generation is the internal generation of the group chat metadata when the sender sent this message.",
		"message":    "message is the textual content.",
		"mode":       "mode is the mode of the message.",
	},
	"PostMetadata": {
		"@":          "PostMetadata is the network-level post data.",
		"version":    "version defines the available fields within attributes.",
		"attributes": "attributes defines the available post attributes.",
	},
	"PostMetadataStatus": {
		"@":          "PostMetadataStatus is the network-level post status update data.",
		"version":    "version defines the available fields within attributes.",
		"from":       "from is the UID of the original status creator.",
		"link":       "link is the ID of the post.",
		"attributes": "attributes is the list of post update attributes.",
	},
	"PublicIdentity": {
		"@":         "PublicIdentity is the lowlevel public identity.",
		"name":      "name is the name of the user.",
		"nick":      "nick is the short name/alias of the user.",
		"sig_key":   "sig_key is the signature key used to authenticate messages from the user.",
		"key":       "key is the NTRU public key of the user.",
		"identity":  "identity is the public ID of the user.",
		"digest":    "digest is a hash of the user's public information.",
		"signature": "signature is a signature of the user's public information.",
	},
	"OOBPublicIdentityInvite": {
		"@":                  "OOBPublicIdentityInvite is an out-of-band invite to perform a KX.",
		"public":             "public is the public identity of the inviter.",
		"initial_rendezvous": "initial_rendezvous is the initial random RV where key exchange will happen.",
		"reset_rendezvous":   "reset_rendezvous is the inviter's reset RV in case of ratchet reset actions.",
	},
	"RMGroupInvite": {
		"@":           "RMGroupInvite is the information about an invite to join a GC.",
		"id":          "id is the ID of the GC.",
		"name":        "name is the name of the GC.",
		"token":       "token is a random number that must be sent back by the invitee to the inviter.",
		"description": "description is a description of the GC.",
		"expires":     "expires is a timestamp for when the invitation expires.",
		"version":     "version is the version of the current definition of the GC.",
	},
	"RMGroupList": {
		"@":            "RMGroupList is the full definition of a GC.",
		"id":           "id is the ID of the GC.",
		"name":         "name is the name of the GC.",
		"generation":   "generation is a monotonically increasing count of GC changes.",
		"timestamp":    "timestamp is the timestamp for the last modification of the GC defintions.",
		"version":      "version is the GC rules version.",
		"members":      "members is the list of user IDs that are in the GC.",
		"extra_admins": "extra_admins is the list of user IDs that are additional admins of the GC.",
	},
}
