// Code generated by protoc-gen-go-svcintf. DO NOT EDIT.
// source: clientrpc.proto

package types

import (
	context "context"
	proto "google.golang.org/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
)

// VersionServiceClient is the client API for VersionService service.
type VersionServiceClient interface {
	// Version returns version information about the server.
	Version(ctx context.Context, in *VersionRequest, out *VersionResponse) error
	// KeepaliveStream returns a stream where the server continuously writes
	// keepalive events.
	//
	// The stream only terminates if the client requests it or the connection to
	// the server is closed.
	KeepaliveStream(ctx context.Context, in *KeepaliveStreamRequest) (VersionService_KeepaliveStreamClient, error)
}

type client_VersionService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_VersionService) Version(ctx context.Context, in *VersionRequest, out *VersionResponse) error {
	const method = "Version"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type VersionService_KeepaliveStreamClient interface {
	Recv(*KeepaliveEvent) error
}

func (c *client_VersionService) KeepaliveStream(ctx context.Context, in *KeepaliveStreamRequest) (VersionService_KeepaliveStreamClient, error) {
	const method = "KeepaliveStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*KeepaliveEvent]{c: inner}, nil
}

func NewVersionServiceClient(c ClientConn) VersionServiceClient {
	return &client_VersionService{c: c, defn: VersionServiceDefn()}
}

// VersionServiceServer is the server API for VersionService service.
type VersionServiceServer interface {
	// Version returns version information about the server.
	Version(context.Context, *VersionRequest, *VersionResponse) error
	// KeepaliveStream returns a stream where the server continuously writes
	// keepalive events.
	//
	// The stream only terminates if the client requests it or the connection to
	// the server is closed.
	KeepaliveStream(context.Context, *KeepaliveStreamRequest, VersionService_KeepaliveStreamServer) error
}

type VersionService_KeepaliveStreamServer interface {
	Send(m *KeepaliveEvent) error
}

func VersionServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "VersionService",
		Methods: map[string]MethodDefn{
			"Version": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(VersionRequest) },
				NewResponse:  func() proto.Message { return new(VersionResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(VersionRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(VersionResponse).ProtoReflect().Descriptor() },
				Help:         "Version returns version information about the server.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(VersionServiceServer).Version(ctx, request.(*VersionRequest), response.(*VersionResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "VersionService.Version"
					return conn.Request(ctx, method, request, response)
				},
			},
			"KeepaliveStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(KeepaliveStreamRequest) },
				NewResponse:  func() proto.Message { return new(KeepaliveEvent) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(KeepaliveStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(KeepaliveEvent).ProtoReflect().Descriptor() },
				Help: "KeepaliveStream returns a stream where the server continuously writes keepalive events.\n" +
					"The stream only terminates if the client requests it or the connection to the server is closed.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(VersionServiceServer).KeepaliveStream(ctx, request.(*KeepaliveStreamRequest), streamerImpl[*KeepaliveEvent]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "VersionService.KeepaliveStream"
					return conn.Stream(ctx, method, request)
				},
			},
		},
	}
}

// ChatServiceClient is the client API for ChatService service.
type ChatServiceClient interface {
	// PM sends a private message to a user of the client.
	PM(ctx context.Context, in *PMRequest, out *PMResponse) error
	// PMStream returns a stream that gets PMs received by the client.
	PMStream(ctx context.Context, in *PMStreamRequest) (ChatService_PMStreamClient, error)
}

type client_ChatService struct {
	c    ClientConn
	defn ServiceDefn
}

func (c *client_ChatService) PM(ctx context.Context, in *PMRequest, out *PMResponse) error {
	const method = "PM"
	return c.defn.Methods[method].ClientHandler(c.c, ctx, in, out)
}

type ChatService_PMStreamClient interface {
	Recv(*ReceivedPM) error
}

func (c *client_ChatService) PMStream(ctx context.Context, in *PMStreamRequest) (ChatService_PMStreamClient, error) {
	const method = "PMStream"
	inner, err := c.defn.Methods[method].ClientStreamHandler(c.c, ctx, in)
	if err != nil {
		return nil, err
	}
	return streamerImpl[*ReceivedPM]{c: inner}, nil
}

func NewChatServiceClient(c ClientConn) ChatServiceClient {
	return &client_ChatService{c: c, defn: ChatServiceDefn()}
}

// ChatServiceServer is the server API for ChatService service.
type ChatServiceServer interface {
	// PM sends a private message to a user of the client.
	PM(context.Context, *PMRequest, *PMResponse) error
	// PMStream returns a stream that gets PMs received by the client.
	PMStream(context.Context, *PMStreamRequest, ChatService_PMStreamServer) error
}

type ChatService_PMStreamServer interface {
	Send(m *ReceivedPM) error
}

func ChatServiceDefn() ServiceDefn {
	return ServiceDefn{
		Name: "ChatService",
		Methods: map[string]MethodDefn{
			"PM": {
				IsStreaming:  false,
				NewRequest:   func() proto.Message { return new(PMRequest) },
				NewResponse:  func() proto.Message { return new(PMResponse) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(PMRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(PMResponse).ProtoReflect().Descriptor() },
				Help:         "PM sends a private message to a user of the client.",
				ServerHandler: func(x interface{}, ctx context.Context, request, response proto.Message) error {
					return x.(ChatServiceServer).PM(ctx, request.(*PMRequest), response.(*PMResponse))
				},
				ClientHandler: func(conn ClientConn, ctx context.Context, request, response proto.Message) error {
					method := "ChatService.PM"
					return conn.Request(ctx, method, request, response)
				},
			},
			"PMStream": {
				IsStreaming:  true,
				NewRequest:   func() proto.Message { return new(PMStreamRequest) },
				NewResponse:  func() proto.Message { return new(ReceivedPM) },
				RequestDefn:  func() protoreflect.MessageDescriptor { return new(PMStreamRequest).ProtoReflect().Descriptor() },
				ResponseDefn: func() protoreflect.MessageDescriptor { return new(ReceivedPM).ProtoReflect().Descriptor() },
				Help:         "PMStream returns a stream that gets PMs received by the client.",
				ServerStreamHandler: func(x interface{}, ctx context.Context, request proto.Message, stream ServerStream) error {
					return x.(ChatServiceServer).PMStream(ctx, request.(*PMStreamRequest), streamerImpl[*ReceivedPM]{s: stream})
				},
				ClientStreamHandler: func(conn ClientConn, ctx context.Context, request proto.Message) (ClientStream, error) {
					method := "ChatService.PMStream"
					return conn.Stream(ctx, method, request)
				},
			},
		},
	}
}

var help_messages = map[string]map[string]string{
	"VersionRequest": {
		"@": "",
	},
	"VersionResponse": {
		"@":           "VersionResponse is the information about the running RPC server.",
		"app_version": "app_version is the version of the application.",
		"go_runtime":  "go_runtime is the Go version the server was compiled with.",
		"app_name":    "app_name is the name of the underlying app running the server.",
	},
	"KeepaliveStreamRequest": {
		"@": "KeepaliveStreamRequest is the request for a new keepalive stream.",
		"interval": "interval is how often to send the keepalive (in milliseconds).\n" +
			"A minimum of 1 second is imposed, regardless of the value passed as interval.",
	},
	"KeepaliveEvent": {
		"@":         "KeepaliveEvent is a single keepalive event.",
		"timestamp": "timestamp is the unix timestamp on the server, with second precision.",
	},
	"PMRequest": {
		"@":    "PMRequest is a request to send a new private message.",
		"user": "user is either the nick, alias or an hex-encoded user ID of the destination.",
		"msg":  "msg is the message to be sent.",
	},
	"PMResponse": {
		"@": "PMResponse is the response of the client for a new message.",
	},
	"PMStreamRequest": {
		"@": "PMStreamRequest is the request for a new private message reception stream.",
	},
	"ReceivedPM": {
		"@":            "ReceivedPM is a private message received by the client.",
		"uid":          "uid is the source user ID in raw format.",
		"nick":         "nick is the source's nick or alias.",
		"msg":          "msg is the received message payload.",
		"timestamp_ms": "timestamp_ms is the timestamp from unix epoch with millisecond precision.",
	},
	"RMPrivateMessage": {
		"@":       "RMPrivateMessage is the network-level routed private message.",
		"message": "message is the private message payload.",
		"mode":    "mode is the message mode.",
	},
}
