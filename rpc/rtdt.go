package rpc

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/binary"
	"errors"
	"fmt"
	"math"
	"slices"
	"time"
	"unsafe"

	"github.com/RoaringBitmap/roaring/v2"
	"github.com/companyzero/bisonrelay/zkidentity"
	"golang.org/x/crypto/nacl/secretbox"
)

const (
	// RTDTMaxMessageSize is the max size of a full UDP RTDT message.
	RTDTMaxMessageSize = 65535

	// RTDTMaxPingInterval is the max interval between receiving pings (or
	// other data) messages.
	RTDTMaxPingInterval = time.Second * 60

	// RTDTDefaultPingInterval is the default interval used by the client
	// to send ping messages.
	RTDTDefaultPingInterval = time.Second * 45

	// RTDTDefaultMinPingInterval is the minimum interval between pings (any
	// lower and the RTDT server disconnects the client).
	RTDTDefaultMinPingInterval = time.Second * 5

	// RTDTMaxPingPayloadSize is the maximum size of the payload in a ping
	// message (in bytes).
	RTDTMaxPingPayloadSize = 256
)

// RTDTStreamType identifies streams of data from a peer within an RTDT
// session.
type RTDTStreamType uint8

const (
	// RTDTStreamRandom is a stream of random data. This is used for
	// testing.
	RTDTStreamRandom RTDTStreamType = 0

	// RTDTStreamSpeech is the default speech stream. This stream consists
	// of Opus-encoded packets, sent in a 20ms interval.
	RTDTStreamSpeech RTDTStreamType = 1

	// RTDTStreamChat is the ephemeral chat stream. This stream consists of
	// UTF-8 encoded text messages.
	RTDTStreamChat RTDTStreamType = 2
)

// rtdtCookiesTag is used to uniquely identify the opaque cookies.
type rtdtCookiesTag [4]byte

var (
	rtdtSessionCookieTag rtdtCookiesTag = [4]byte{0x53, 0x43, 0x4b, 0x73} // SCKI
	rtdtAppointCookieTag rtdtCookiesTag = [4]byte{0x41, 0x43, 0x4b, 0x73} // ACKI
	rtdtJoinCookieTag    rtdtCookiesTag = [4]byte{0x4a, 0x43, 0x4b, 0x73} // JCKI
	rtdtRotateCookieTag  rtdtCookiesTag = [4]byte{0x52, 0x43, 0x4b, 0x73} // RCKI
)

// RTDTPeerID is a peer identifier inside RTDT framed messages.
type RTDTPeerID uint32

func (id RTDTPeerID) String() string {
	return fmt.Sprintf("%08x", uint32(id))
}

// Next returns the next valid peer id, given id as a starting point.
func (id RTDTPeerID) Next() RTDTPeerID {
	next := id + 1
	if next == 0 {
		next++
	}
	return next
}

// RTDTSessionCookie is sent by a session owner or admin to manage an RTDT
// session.
type RTDTSessionCookie struct {
	// ServerSecret is random server data. This is used as part of the full
	// session id.
	ServerSecret zkidentity.ShortID

	// Size is the size of the RTDT session (max number of concurrent
	// peers).
	Size uint32
}

// Encrypt encrypts the session cookie using the specified key.
func (sc *RTDTSessionCookie) Encrypt(out []byte, key *zkidentity.FixedSizeSymmetricKey) []byte {
	var data [4 + 32 + 4]byte
	copy(data[:], rtdtSessionCookieTag[:]) // Unique tag for session cookie.
	copy(data[4:], sc.ServerSecret[:])
	binary.BigEndian.PutUint32(data[36:], sc.Size)

	var nonce [24]byte
	rand.Read(nonce[:])
	out = append(out, nonce[:]...)
	out = secretbox.Seal(out, data[:], &nonce, (*[32]byte)(key))
	return out
}

// Decrypt and authenticate the input stream as a session cookie using the
// specified key.
func (sc *RTDTSessionCookie) Decrypt(in []byte, key *zkidentity.FixedSizeSymmetricKey, extraKeys []*zkidentity.FixedSizeSymmetricKey) error {
	const payload = 4 + 32 + 4
	if len(in) < 24+payload+16 {
		return fmt.Errorf("input data is too short (got %d)", len(in))
	}
	var nonce [24]byte
	copy(nonce[:], in)
	in = in[24:]

	var data [payload]byte
	_, ok := secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
	if !ok {
		// Try to decode with additional keys.
		for _, key := range extraKeys {
			_, ok = secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
			if ok {
				break
			}
		}

		if !ok {
			return errors.New("failed to decrypt input data")
		}
	}

	if !bytes.Equal(data[:4], rtdtSessionCookieTag[:]) {
		return errors.New("wrong cookie tag")
	}

	copy(sc.ServerSecret[:], data[4:])
	sc.Size = binary.BigEndian.Uint32(data[36:])

	return nil
}

// RTDTAppointCookie is shared by the RTDT session owner with a client to allow
// the client to join as a peer in the same session in the RTDT server.
type RTDTAppointCookie struct {
	// ServerSecret is the random server secret data.
	ServerSecret zkidentity.ShortID

	// OwnerSecret is random data generated by the owner. This is used as
	// part of the session identifier within the RTDT server.
	OwnerSecret zkidentity.ShortID

	// Size is the size of the session.
	Size uint32

	// PeerID is the peer ID that should be used by the client.
	PeerID RTDTPeerID

	// AllowedAsPublisher is true if this peer is allowed to send data in
	// the session.
	AllowedAsPublisher bool

	// IsAdmin is true if this peer is allowed to admin the live RTDT
	// session.
	IsAdmin bool
}

const (
	rtdtCookieFlagAllowedAsPublisher = 0
	rtdtCookieFlagIsAdmin            = 1
)

// Encrypt encrypts the appontment cookie using the specified key.
func (ac *RTDTAppointCookie) Encrypt(out []byte, key *zkidentity.FixedSizeSymmetricKey) []byte {

	var flags uint8
	flags = setBoolFlag(flags, rtdtCookieFlagAllowedAsPublisher, ac.AllowedAsPublisher)
	flags = setBoolFlag(flags, rtdtCookieFlagIsAdmin, ac.IsAdmin)

	var data [4 + 32 + 32 + 4 + 4 + 1]byte
	copy(data[:], rtdtAppointCookieTag[:]) // Unique tag for appointment cookie.
	copy(data[4:], ac.ServerSecret[:])
	copy(data[36:], ac.OwnerSecret[:])
	binary.BigEndian.PutUint32(data[68:], ac.Size)
	binary.BigEndian.PutUint32(data[72:], uint32(ac.PeerID))
	data[76] = flags

	var nonce [24]byte
	rand.Read(nonce[:])
	out = append(out, nonce[:]...)
	out = secretbox.Seal(out, data[:], &nonce, (*[32]byte)(key))
	return out
}

// Decrypt decrypts and authenticates the given data as an appointment cookie.
func (ac *RTDTAppointCookie) Decrypt(in []byte, key *zkidentity.FixedSizeSymmetricKey,
	extraKeys []*zkidentity.FixedSizeSymmetricKey) error {

	const payload = 4 + 32 + 32 + 4 + 4 + 1
	if len(in) < 24+payload+16 {
		return fmt.Errorf("input data is too short (got %d)", len(in))
	}
	var nonce [24]byte
	copy(nonce[:], in)
	in = in[24:]

	var data [payload]byte
	_, ok := secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
	if !ok {
		// Try to decode with additional keys.
		for _, key := range extraKeys {
			_, ok = secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
			if ok {
				break
			}
		}

		if !ok {
			return errors.New("failed to decrypt input data")
		}
	}

	if !bytes.Equal(data[:4], rtdtAppointCookieTag[:]) {
		return errors.New("wrong cookie tag")
	}

	copy(ac.ServerSecret[:], data[4:])
	copy(ac.OwnerSecret[:], data[36:])
	ac.Size = binary.BigEndian.Uint32(data[68:])
	ac.PeerID = RTDTPeerID(binary.BigEndian.Uint32(data[72:]))
	flags := data[76]
	ac.AllowedAsPublisher = isBoolFlagSet(flags, rtdtCookieFlagAllowedAsPublisher)
	ac.IsAdmin = isBoolFlagSet(flags, rtdtCookieFlagIsAdmin)

	return nil
}

// RTDTJoinCookie is sent by the client to the RTDT server to uniquely identify
// the session it is joining and to extend its publish allowance.
type RTDTJoinCookie struct {
	// ServerSecret is the random server secret data.
	ServerSecret zkidentity.ShortID

	// OwnerSecret is random data generated by the owner. This is used as
	// part of the session identifier within the RTDT server.
	OwnerSecret zkidentity.ShortID

	// Size is the size of the session.
	Size uint32

	// PeerID is the peer ID that should be used by the client.
	PeerID RTDTPeerID

	// EndTimestamp determines when this join cookie expires.
	EndTimestamp int64 `json:"end_timestamp"`

	// PublishAllowance is the total number of bytes that this user may send
	// using this join cookie.
	PublishAllowance uint64 `json:"publish_allowance"`

	// PaymentTag is a unique payment identifier for this join cookie.
	PaymentTag uint64 `json:"payment_tag"`

	// IsAdmin is true if this client is allowed as an admin.
	IsAdmin bool `json:"is_admin"`
}

// Encrypt encrypts the join cookie with the specified key.
func (jc *RTDTJoinCookie) Encrypt(out []byte, key *zkidentity.FixedSizeSymmetricKey) []byte {
	var flags uint8
	flags = setBoolFlag(flags, rtdtCookieFlagIsAdmin, jc.IsAdmin)

	var data [4 + 32 + 32 + 4 + 4 + 8 + 8 + 8 + 1]byte
	copy(data[:], rtdtJoinCookieTag[:]) // Unique tag for join cookie.
	copy(data[4:], jc.ServerSecret[:])
	copy(data[36:], jc.OwnerSecret[:])
	binary.BigEndian.PutUint32(data[68:], uint32(jc.PeerID))
	binary.BigEndian.PutUint32(data[72:], jc.Size)
	binary.BigEndian.PutUint64(data[76:], uint64(jc.EndTimestamp))
	binary.BigEndian.PutUint64(data[84:], jc.PublishAllowance)
	binary.BigEndian.PutUint64(data[92:], jc.PaymentTag)
	data[100] = flags

	var nonce [24]byte
	rand.Read(nonce[:])
	out = append(out, nonce[:]...)
	out = secretbox.Seal(out, data[:], &nonce, (*[32]byte)(key))
	return out
}

// Decrypt decrypts and authenticates the given data as a join cookie.
func (jc *RTDTJoinCookie) Decrypt(in []byte, key *zkidentity.FixedSizeSymmetricKey, extraKeys []*zkidentity.FixedSizeSymmetricKey) error {
	const payloadLen = 4 + 32 + 32 + 4 + 4 + 8 + 8 + 8 + 1
	if len(in) < 24+payloadLen+16 {
		return fmt.Errorf("input data is too short (got %d)", len(in))
	}
	var nonce [24]byte
	copy(nonce[:], in)
	in = in[24:]

	var data [payloadLen]byte
	_, ok := secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
	if !ok {
		// Try to decode with additional keys.
		for _, key := range extraKeys {
			_, ok = secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
			if ok {
				break
			}
		}

		if !ok {
			return errors.New("failed to decrypt input data")
		}
	}

	if !bytes.Equal(data[:4], rtdtJoinCookieTag[:]) {
		return errors.New("wrong cookie tag")
	}

	copy(jc.ServerSecret[:], data[4:])
	copy(jc.OwnerSecret[:], data[36:])
	jc.PeerID = RTDTPeerID(binary.BigEndian.Uint32(data[68:]))
	jc.Size = binary.BigEndian.Uint32(data[72:])
	jc.EndTimestamp = int64(binary.BigEndian.Uint64(data[76:]))
	jc.PublishAllowance = binary.BigEndian.Uint64(data[84:])
	jc.PaymentTag = binary.BigEndian.Uint64(data[92:])
	flags := data[100]
	jc.IsAdmin = isBoolFlagSet(flags, rtdtCookieFlagIsAdmin)

	return nil
}

// RTDTRotateCookie is the cookie used when an admin wants to rotate the
// secrets in a live session.
type RTDTRotateCookie struct {
	// ServerSecret is the random server secret data.
	ServerSecret zkidentity.ShortID `json:"server_secret"`

	// OldOwnerSecret is the previous OwnerSecret value.
	OldOwnerSecret zkidentity.ShortID `json:"old_owner_secret"`

	// NewOwnerSecret is the new OwnerSecret value.
	NewOwnerSecret zkidentity.ShortID `json:"new_owner_secret"`

	// Size is the size of the session.
	Size uint32 `json:"size"`

	// Timestamp is the unix timestamp in seconds of when this cookie was
	// generated.
	Timestamp int64 `json:"timestamp"`

	// PaymentTag is a unique identifier of the cookie.
	PaymentTag uint64 `json:"payment_tag"`
}

// Encrypt encrypts the cookie in out.
func (rc *RTDTRotateCookie) Encrypt(out []byte, key *zkidentity.FixedSizeSymmetricKey) []byte {
	const payloadLen = 4 + 32*3 + 4 + 8 + 8
	var data [payloadLen]byte

	copy(data[:], rtdtRotateCookieTag[:]) // Unique tag for rotate cookie.
	copy(data[4:], rc.ServerSecret[:])
	copy(data[36:], rc.OldOwnerSecret[:])
	copy(data[68:], rc.NewOwnerSecret[:])
	binary.BigEndian.PutUint32(data[100:], rc.Size)
	binary.BigEndian.PutUint64(data[104:], uint64(rc.Timestamp))
	binary.BigEndian.PutUint64(data[112:], rc.PaymentTag)

	var nonce [24]byte
	rand.Read(nonce[:])
	out = append(out, nonce[:]...)
	out = secretbox.Seal(out, data[:], &nonce, (*[32]byte)(key))
	return out
}

// Decrypt decrypts the cookie from in.
func (rc *RTDTRotateCookie) Decrypt(in []byte, key *zkidentity.FixedSizeSymmetricKey,
	extraKeys []*zkidentity.FixedSizeSymmetricKey) error {

	const payloadLen = 4 + 32*3 + 4 + 8 + 8
	if len(in) < 24+payloadLen+16 {
		return fmt.Errorf("input data is too short (got %d)", len(in))
	}
	var nonce [24]byte
	copy(nonce[:], in)
	in = in[24:]

	var data [payloadLen]byte
	_, ok := secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
	if !ok {
		// Try to decode with additional keys.
		for _, key := range extraKeys {
			_, ok = secretbox.Open(data[:0], in, &nonce, (*[32]byte)(key))
			if ok {
				break
			}
		}

		if !ok {
			return errors.New("failed to decrypt input data")
		}
	}

	if !bytes.Equal(data[:4], rtdtRotateCookieTag[:]) {
		return errors.New("wrong cookie tag")
	}

	copy(rc.ServerSecret[:], data[4:])
	copy(rc.OldOwnerSecret[:], data[36:])
	copy(rc.NewOwnerSecret[:], data[68:])
	rc.Size = binary.BigEndian.Uint32(data[100:])
	rc.Timestamp = int64(binary.BigEndian.Uint64(data[104:]))
	rc.PaymentTag = binary.BigEndian.Uint64(data[112:])
	return nil
}

// RTDTServerCmdType defines the known server commands.
type RTDTServerCmdType uint8

const (
	RTDTServerCmdTypePing               RTDTServerCmdType = 0x01
	RTDTServerCmdTypePong               RTDTServerCmdType = 0x02
	RTDTServerCmdTypeJoinSession        RTDTServerCmdType = 0x03
	RTDTServerCmdTypeJoinSessionReply   RTDTServerCmdType = 0x04
	RTDTServerCmdTypeLeaveSession       RTDTServerCmdType = 0x05
	RTDTServerCmdTypeLeaveSessionReply  RTDTServerCmdType = 0x06
	RTDTServerCmdTypeKickPeer           RTDTServerCmdType = 0x07
	RTDTServerCmdTypeKickPeerReply      RTDTServerCmdType = 0x08
	RTDTServerCmdTypeMembersBitmap      RTDTServerCmdType = 0x09
	RTDTServerCmdTypeRotateCookies      RTDTServerCmdType = 0x0a
	RTDTServerCmdTypeRotateCookiesReply RTDTServerCmdType = 0x0b
)

// RTDTFramedPacket is an RTDT-framed (possibly end-to-end encrypted) packet,
// relayed between an RTDT server and client.
type RTDTFramedPacket struct {
	// Target is the peer id of the receiving client in the channel. When
	// sending, this will equal Source to route a data packet to every
	// member of the session. Otherwise, this will be processed as an
	// internal server command.
	Target RTDTPeerID

	// Source is the peer id of the sending client. When receiving, this
	// will be zero for replies to server commands.
	Source RTDTPeerID

	// Sequence is used to drop old packets.
	Sequence uint32

	// Data is the framed packet data. This may be (possibly E2E encrypted)
	// RTDTDataPacket or a serialized server command.
	Data []byte
}

// FromBytes decodes the byte slice into this framed packet.
func (p *RTDTFramedPacket) FromBytes(b []byte) error {
	if len(b) < 12 {
		return errors.New("framed packet is too short")
	}

	p.Target = RTDTPeerID(binary.BigEndian.Uint32(b))
	p.Source = RTDTPeerID(binary.BigEndian.Uint32(b[4:]))
	p.Sequence = binary.BigEndian.Uint32(b[8:])
	p.Data = b[12:]
	return nil
}

// headerSize returns the size of the header portion of a framed packet.
func (p *RTDTFramedPacket) headerSize() int { return 4 + 4 + 4 }

// appendPacketHeader appends this packet's header into a byte slice.
func (p *RTDTFramedPacket) appendPacketHeader(b []byte) []byte {
	b = binary.BigEndian.AppendUint32(b, uint32(p.Target))
	b = binary.BigEndian.AppendUint32(b, uint32(p.Source))
	b = binary.BigEndian.AppendUint32(b, p.Sequence)
	return b
}

// ServerCmd decodes the packet as a server command and payload.
func (p *RTDTFramedPacket) ServerCmd() (RTDTServerCmdType, []byte) {
	if len(p.Data) < 1 {
		return 0, nil
	}

	switch RTDTServerCmdType(p.Data[0]) {
	case RTDTServerCmdTypePing:
		return RTDTServerCmdTypePing, p.Data[1:]
	case RTDTServerCmdTypePong:
		return RTDTServerCmdTypePong, p.Data[1:]
	case RTDTServerCmdTypeJoinSession:
		return RTDTServerCmdTypeJoinSession, p.Data[1:]
	case RTDTServerCmdTypeJoinSessionReply:
		return RTDTServerCmdTypeJoinSessionReply, p.Data[1:]
	case RTDTServerCmdTypeLeaveSession:
		return RTDTServerCmdTypeLeaveSession, p.Data[1:]
	case RTDTServerCmdTypeLeaveSessionReply:
		return RTDTServerCmdTypeLeaveSessionReply, p.Data[1:]
	case RTDTServerCmdTypeKickPeer:
		return RTDTServerCmdTypeKickPeer, p.Data[1:]
	case RTDTServerCmdTypeKickPeerReply:
		return RTDTServerCmdTypeKickPeerReply, p.Data[1:]
	case RTDTServerCmdTypeMembersBitmap:
		return RTDTServerCmdTypeMembersBitmap, p.Data[1:]
	case RTDTServerCmdTypeRotateCookies:
		return RTDTServerCmdTypeRotateCookies, p.Data[1:]
	case RTDTServerCmdTypeRotateCookiesReply:
		return RTDTServerCmdTypeRotateCookiesReply, p.Data[1:]
	default:
		return 0, nil
	}
}

// RTDTDataPacket is the end-to-end data sent between clients through an RTDT
// relay server.
type RTDTDataPacket struct {
	// Stream is the identifier of the logical media stream related to this
	// data.
	Stream RTDTStreamType

	// Timestamp is a monotonically increasing timestamp of the media.
	Timestamp uint32

	// Data is the actual data.
	Data []byte

	// temp is used as a temporary buffer when sending/receiving E2E
	// encrypted data packets.
	temp []byte
}

const (
	rtdtPacketContainsSigFlag = 0x01
)

// aliasNonce aliases a nonce into a byte slice. This avoids having to allocate
// and copy the nonce into a new array.
func aliasNonce(b []byte) *[24]byte {
	_ = b[23] // Bounds check.
	return (*[24]byte)(unsafe.Pointer(unsafe.SliceData(b)))
}

// Decrypt decrypts and deserializes the data inside the framed packet into
// this data packet.
//
// If the encryption key is provided, the framed data is assumed to be encrypted
// and is thus authenticated and decrypted.
//
// If the signature key is provided and the source packet has a signature,
// then the signature is also validated.
func (p *RTDTDataPacket) Decrypt(source RTDTFramedPacket,
	encryptionKey *zkidentity.FixedSizeSymmetricKey, sigKey *zkidentity.FixedSizeEd25519PublicKey) error {

	plain := source.Data
	if encryptionKey != nil {
		if len(plain) < 24+secretbox.Overhead {
			return errors.New("ciphertext is too short")
		}

		var ok bool
		nonce, cipher := source.Data[:24], source.Data[24:]
		key := (*[32]byte)(encryptionKey)
		plain, ok = secretbox.Open(p.temp[:0], cipher, aliasNonce(nonce), key)
		if !ok {
			return errors.New("decryption error")
		}
		p.temp = plain
	}

	if len(plain) < 1 {
		return errors.New("decrypted data is empty")
	}
	header := plain[0]
	if (header & rtdtPacketContainsSigFlag) == rtdtPacketContainsSigFlag {
		if len(plain) < ed25519.SignatureSize+6 {
			return errors.New("decrypted data does not contain signature")
		}

		// Contains signature bytes at footer.
		i := len(plain) - ed25519.SignatureSize
		msg, sig := plain[:i], plain[i:]
		if sigKey != nil && !ed25519.Verify(sigKey[:], msg, sig) {
			return errors.New("decrypted data failed signature validation")
		}

		p.Data = msg[6:]
	} else {
		if len(plain) < 6 {
			return errors.New("decrypted data is too short")
		}

		p.Data = plain[6:]
	}

	p.Stream = RTDTStreamType(plain[1])
	p.Timestamp = binary.BigEndian.Uint32(plain[2:])

	return nil
}

// AppendEncrypted appends a (possibly signed and encrypted) framed version of
// the data packet into out.
func (p *RTDTDataPacket) AppendEncrypted(pkt *RTDTFramedPacket, out []byte,
	encryptionKey *zkidentity.FixedSizeSymmetricKey,
	sigKey *zkidentity.FixedSizeEd25519PrivateKey) []byte {

	// TODO: avoid copy by creating a OutboundPlainTextBuf
	// and sizing it by leaving enough room for the header at the
	// start. Use that buffer to capture audio data.

	tempLen := 6 + len(p.Data)
	var header byte
	if sigKey != nil {
		tempLen += ed25519.SignatureSize
		header |= rtdtPacketContainsSigFlag
	}
	plain := slices.Grow(p.temp[:0], tempLen)
	plain = append(plain, header)
	plain = append(plain, byte(p.Stream))
	plain = binary.BigEndian.AppendUint32(plain, p.Timestamp)
	plain = append(plain, p.Data...)

	if sigKey != nil {
		sig := ed25519.Sign(sigKey[:], plain)
		plain = append(plain, sig...)
	}

	out = slices.Grow(out, pkt.headerSize()+24+len(plain)+16)
	out = pkt.appendPacketHeader(out)
	if encryptionKey != nil {
		var nonce []byte
		key := (*[32]byte)(encryptionKey)
		nonce, out = out[len(out):len(out)+24], out[:len(out)+24]
		rand.Read(nonce)
		out = secretbox.Seal(out, plain, aliasNonce(nonce), key)
	} else {
		out = append(out, plain...)
	}

	pkt.Data = out[10:]

	clear(plain)
	p.temp = plain

	return out
}

// AppendFramed appends a framed version of this packet to out.
//
// NOTE: this appends the raw contents of the data packet directily, without
// signing or performing encryption. For those, see AppendEncrypted.
func (p *RTDTDataPacket) AppendFramed(pkt *RTDTFramedPacket, out []byte) []byte {
	out = pkt.appendPacketHeader(out)

	var header byte
	out = append(out, header)
	out = append(out, byte(p.Stream))
	out = binary.BigEndian.AppendUint32(out, p.Timestamp)
	out = append(out, p.Data...)

	return out
}

// RTDTPingCmd is the command to ping the server.
type RTDTPingCmd struct {
	// Data is opaque data sent by the sender.
	Data []byte
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTPingCmd) FromBytes(b []byte) error {
	c.Data = b
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTPingCmd) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypePing))
	b = append(b, c.Data...)
	return b
}

// RTDTPongCmd is the reply to a ping command.
type RTDTPongCmd struct {
	// Data is opaque data, originally sent by the sender of the
	// corresponding Ping.
	Data []byte
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTPongCmd) FromBytes(b []byte) error {
	c.Data = b
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTPongCmd) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypePong))
	b = append(b, c.Data...)
	return b
}

// RTDTServerCmdJoinSession is the command to join a session in the server.
type RTDTServerCmdJoinSession struct {
	// JoinCookie is an opaque cookie generated from brserver and sent to
	// the RTDT server.
	JoinCookie []byte
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdJoinSession) FromBytes(b []byte) error {
	c.JoinCookie = b
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdJoinSession) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeJoinSession))
	b = append(b, c.JoinCookie...)
	return b
}

// RTDTServerCmdJoinSessionReply is the reply sent to a join session command.
type RTDTServerCmdJoinSessionReply struct {
	// ErrCode is the error code for processing this message.
	//
	// Note: the error code is only set when the server is running with
	// a debug flag set. When that flag is not set, this field will be empty
	// even when the session binding failed.
	ErrCode uint64
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdJoinSessionReply) FromBytes(b []byte) error {
	if len(b) < 8 {
		return errors.New("too few bytes to decode message")
	}

	c.ErrCode = binary.BigEndian.Uint64(b)
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdJoinSessionReply) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeJoinSessionReply))
	b = binary.BigEndian.AppendUint64(b, c.ErrCode)
	return b
}

// RTDTServerCmdLeaveSession is a RTDT server command to leave a previously
// joined session.
type RTDTServerCmdLeaveSession struct{}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdLeaveSession) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeLeaveSession))
	return b
}

// RTDTServerCmdLeaveSessionReply is the reply to the previously sent leave
// session server command.
type RTDTServerCmdLeaveSessionReply struct{}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdLeaveSessionReply) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeLeaveSessionReply))
	return b
}

// RTDTServerCmdKickPeer is a RTDT server command to kick a peer from a
// session.
//
// Can only be issued by admins.
type RTDTServerCmdKickPeer struct {
	KickTarget         RTDTPeerID
	BanDurationSeconds uint32
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdKickPeer) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeKickPeer))
	b = binary.BigEndian.AppendUint32(b, uint32(c.KickTarget))
	b = binary.BigEndian.AppendUint32(b, c.BanDurationSeconds)
	return b
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdKickPeer) FromBytes(b []byte) error {
	if len(b) < 8 {
		return errors.New("too few bytes to decode message")
	}

	c.KickTarget = RTDTPeerID(binary.BigEndian.Uint32(b))
	c.BanDurationSeconds = binary.BigEndian.Uint32(b[4:])
	return nil
}

// RTDTServerCmdKickPeerReply is the reply to a kick peer command.
type RTDTServerCmdKickPeerReply struct {
	// KickTarget is the original target of the kick request.
	KickTarget RTDTPeerID

	// ErrCode is the error code for processing this message.
	//
	// Note: the error code is only set when the server is running with
	// a debug flag set. When that flag is not set, this field will be empty
	// even when the command failed.
	ErrCode uint64
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdKickPeerReply) FromBytes(b []byte) error {
	if len(b) < 12 {
		return errors.New("too few bytes to decode message")
	}

	c.KickTarget = RTDTPeerID(binary.BigEndian.Uint32(b))
	c.ErrCode = binary.BigEndian.Uint64(b[4:])
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdKickPeerReply) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeKickPeerReply))
	b = binary.BigEndian.AppendUint32(b, uint32(c.KickTarget))
	b = binary.BigEndian.AppendUint64(b, c.ErrCode)
	return b
}

// RTDTServerCmdMembersBitmap is a command from the server that lists the
// current member IDs bound to a session.
type RTDTServerCmdMembersBitmap struct {
	// Bitmap is a serialization of a roaring bitmap of peer IDs.
	Bitmap []byte
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdMembersBitmap) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeMembersBitmap))
	b = append(b, c.Bitmap...)
	return b
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdMembersBitmap) FromBytes(b []byte) error {
	c.Bitmap = b
	return nil
}

// DecodeBitmap decodes the bitmap data into a roaring bitmap object.
func (c *RTDTServerCmdMembersBitmap) DecodeBitmap(bmp *roaring.Bitmap) error {
	_, err := bmp.FromBuffer(c.Bitmap)
	if err != nil {
		return err
	}
	return bmp.Validate()
}

// ToBitmap decodes the bitmap data into a new roaring bitmap object.
func (c *RTDTServerCmdMembersBitmap) ToBitmap() (*roaring.Bitmap, error) {
	bmp := roaring.NewBitmap()
	err := c.DecodeBitmap(bmp)
	return bmp, err
}

// RTDTServerCmdRotateSessionCookies rotates the session ID of a given session
// with every member. This has the side effect of banning anyone not in
// possession of new appointment cookies.
type RTDTServerCmdRotateSessionCookies struct {
	RotateCookie []byte
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdRotateSessionCookies) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeRotateCookies))
	b = append(b, c.RotateCookie...)
	return b
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdRotateSessionCookies) FromBytes(b []byte) error {
	c.RotateCookie = b
	return nil
}

// RTDTServerCmdRotateSessionCookiesReply is the reply to a rotate session
// cookies command.
type RTDTServerCmdRotateSessionCookiesReply struct {
	ErrCode uint64
}

// FromBytes decodes this command from a byte slice.
func (c *RTDTServerCmdRotateSessionCookiesReply) FromBytes(b []byte) error {
	if len(b) < 8 {
		return errors.New("too few bytes to decode message")
	}

	c.ErrCode = binary.BigEndian.Uint64(b)
	return nil
}

// AppendFramed appends a framed version of this command to b.
func (c *RTDTServerCmdRotateSessionCookiesReply) AppendFramed(pkt *RTDTFramedPacket, b []byte) []byte {
	b = pkt.appendPacketHeader(b)
	b = append(b, byte(RTDTServerCmdTypeRotateCookiesReply))
	b = binary.BigEndian.AppendUint64(b, c.ErrCode)
	return b
}

// CalcRTDTSessPushMAtoms calculates the amount to pay to send data in a RTDT
// session with the passed parameters.
func CalcRTDTSessPushMAtoms(joinRate, payRateMAtoms, payRateMB uint64,
	sessMB, sessSize uint32) (int64, error) {

	if payRateMB == 0 {
		return 0, errPushCostZeroBytes
	}

	sizeTimesMB := uint64(sessSize) * uint64(sessMB)
	v := sizeTimesMB * payRateMAtoms
	if sizeTimesMB != 0 && v/sizeTimesMB != payRateMAtoms {
		return 0, errPushCostOverflows
	}
	if v > math.MaxInt64 {
		return 0, errPushCostOverflowsInt64
	}

	payAmount := int64(v/payRateMB + joinRate)
	return payAmount, nil
}

var (
	errRTDTSessPaymentLowerThanMin = errors.New("payment was lower than the minimum join rate")
	errRTDTSessPaymentNegative     = errors.New("negative payment amount")
)

// CalcRTDTSessPushMB calculates the number of MB paid to push data in an RTDT
// session with the passed parameters.
//
// This is the inverse of CalcRTDTSessPushMAtoms.
func CalcRTDTSessPushMB(joinRate, payRateMAtoms, payRateMB uint64,
	sessSize uint32, paidMAtoms int64) (uint32, error) {

	if payRateMB == 0 {
		return 0, errPushCostZeroBytes
	}

	if paidMAtoms < 0 {
		return 0, errRTDTSessPaymentNegative
	}

	if uint64(paidMAtoms) < joinRate {
		return 0, errRTDTSessPaymentLowerThanMin
	}

	paidMAtoms -= int64(joinRate)
	sessMB := (uint64(paidMAtoms) * payRateMB) / (uint64(sessSize) * payRateMAtoms)
	if sessMB > math.MaxInt32 {
		sessMB = math.MaxInt32
	}

	return uint32(sessMB), nil
}
