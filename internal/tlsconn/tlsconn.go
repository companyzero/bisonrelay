package tlsconn

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io"
	"math/big"
	"net"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/decred/dcrd/certgen"
	"github.com/decred/slog"
)

// TLSListenersConfig is the config for a new set of TLS listeners.
type TLSListenersConfig struct {
	// Addresses are the addresses, with the port appended.
	Addresses []string

	// Listening cert options.

	CertPath                  string
	KeyPath                   string
	CreateCertPairIfNotExists bool

	// Client cert options. If clientCAPath != "", then client cert auth
	// is enabled.

	ClientCAPath                string
	ClientCertPath              string
	ClientKeyPath               string
	CreateClientCertIfNotExists bool

	Log slog.Logger
}

func generateKeyPair(certPath, keyPath string) (tls.Certificate, error) {
	// Create directories for cert and key files if they do not yet exist.
	err := os.MkdirAll(filepath.Dir(certPath), 0700)
	if err != nil {
		return tls.Certificate{}, err
	}

	// Generate cert pair.
	org := "bisonrelay autogenerated cert"
	validUntil := time.Now().Add(time.Hour * 24 * 365 * 10)
	cert, key, err := certgen.NewEd25519TLSCertPair(org, validUntil, nil)
	if err != nil {
		return tls.Certificate{}, err
	}
	keyPair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		return tls.Certificate{}, err
	}

	// Write cert and (potentially) the key files.
	err = os.WriteFile(certPath, cert, 0o600)
	if err != nil {
		return tls.Certificate{}, err
	}
	if keyPath != "" {
		err = os.MkdirAll(filepath.Dir(keyPath), 0o700)
		if err != nil {
			return tls.Certificate{}, err
		}

		err = os.WriteFile(keyPath, key, 0o600)
		if err != nil {
			_ = os.Remove(certPath)
			return tls.Certificate{}, err
		}
	}

	return keyPair, nil
}

func randomX509SerialNumber() (*big.Int, error) {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return nil, fmt.Errorf("failed to generate serial number: %s", err)
	}
	return serialNumber, nil
}

func generateClientCert(caPath, clientCertPath, clientKeyPath string) ([]byte, error) {
	const createFileFlags = os.O_RDWR | os.O_CREATE | os.O_TRUNC

	// Create the dirs.
	if err := os.MkdirAll(filepath.Dir(caPath), 0o700); err != nil {
		return nil, fmt.Errorf("unable to create client CA dir: %v", err)
	}
	if err := os.MkdirAll(filepath.Dir(clientCertPath), 0o700); err != nil {
		return nil, fmt.Errorf("unable to create client cert dir: %v", err)
	}
	if err := os.MkdirAll(filepath.Dir(clientKeyPath), 0o700); err != nil {
		return nil, fmt.Errorf("unable to create client key dir: %v", err)
	}

	// End of ASN.1 time
	var endOfTime = time.Date(2049, 12, 31, 23, 59, 59, 0, time.UTC)

	// Create CA keypair.
	seed := make([]byte, ed25519.SeedSize)
	if _, err := io.ReadFull(rand.Reader, seed); err != nil {
		return nil, err
	}
	caPriv := ed25519.NewKeyFromSeed(seed)
	caPub := caPriv.Public()

	// Create CA cert.
	validUntil := time.Now().Add(time.Hour * 24 * 365 * 10)
	now := time.Now()
	if validUntil.After(endOfTime) {
		validUntil = endOfTime
	}
	if validUntil.Before(now) {
		return nil, fmt.Errorf("valid until date %v already elapsed", validUntil)
	}
	serialNumber, err := randomX509SerialNumber()
	if err != nil {
		return nil, err
	}
	caTemplate := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:         "bisonrelay",
			Organization:       []string{"bisonrelay"},
			OrganizationalUnit: []string{"bisonrelay certificate authority"},
		},
		NotBefore:             now.Add(-time.Hour * 24),
		NotAfter:              validUntil,
		KeyUsage:              x509.KeyUsageCertSign,
		BasicConstraintsValid: true,
		IsCA:                  true,
	}

	// Encode the CA cert into file.
	caCertBytes, err := x509.CreateCertificate(rand.Reader, caTemplate, caTemplate, caPub, caPriv)
	if err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	err = pem.Encode(buf, &pem.Block{Type: "CERTIFICATE", Bytes: caCertBytes})
	if err != nil {
		return nil, fmt.Errorf("failed to encode certificate: %v", err)
	}
	caFile := buf.Bytes()
	if err := os.WriteFile(caPath, caFile, 0o600); err != nil {
		return nil, fmt.Errorf("unable to write client CA cert file: %v", err)
	}
	caCert, err := x509.ParseCertificate(caCertBytes)
	if err != nil {
		return nil, err
	}

	// Create client keypair.
	if _, err := io.ReadFull(rand.Reader, seed); err != nil {
		return nil, err
	}
	clientPriv := ed25519.NewKeyFromSeed(seed)
	clientPub := clientPriv.Public()

	// Save client key to file.
	der, err := x509.MarshalPKCS8PrivateKey(clientPriv)
	if err != nil {
		return nil, fmt.Errorf("unable to marshal client private key: %v", err)
	}
	clientPrivFile, err := os.OpenFile(clientKeyPath, createFileFlags, 0o0600)
	if err != nil {
		return nil, fmt.Errorf("unable to create client key file: %v", err)
	}
	defer clientPrivFile.Close()
	err = pem.Encode(clientPrivFile, &pem.Block{Type: "PRIVATE KEY", Bytes: der})
	if err != nil {
		return nil, fmt.Errorf("unable to encode client key: %v", err)
	}

	// Create and sign client cert.
	serialNumber, err = randomX509SerialNumber()
	if err != nil {
		return nil, err
	}
	clientTemplate := &x509.Certificate{
		SerialNumber: serialNumber,
		NotBefore:    time.Now().Add(-time.Hour * 24),
		NotAfter:     caTemplate.NotAfter,
		Subject: pkix.Name{
			CommonName:         "bisonrelay",
			Organization:       []string{"bisonrelay"},
			OrganizationalUnit: []string{"bisonrelay client certificate"},
		},
	}
	cert, err := x509.CreateCertificate(rand.Reader, clientTemplate, caCert,
		clientPub, caPriv)
	if err != nil {
		return nil, err
	}

	// Save client cert to file.
	clientCertFile, err := os.OpenFile(clientCertPath, createFileFlags, 0o0600)
	if err != nil {
		return nil, fmt.Errorf("unable to create client cert file: %v", err)
	}
	defer clientCertFile.Close()
	err = pem.Encode(clientCertFile, &pem.Block{Type: "CERTIFICATE", Bytes: cert})
	if err != nil {
		return nil, fmt.Errorf("failed to encode certificate: %v", err)
	}

	return caFile, nil
}

// listen binds to the specified address, both on tcp4 and tcp6.
func listen(addr string) ([]net.Listener, error) {
	var hasIPv4, hasIPv6 bool

	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return nil, fmt.Errorf("`%s` is not a normalized "+
			"listener address", addr)
	}

	// Empty host or host of * on plan9 is both IPv4 and IPv6.
	if host == "" || (host == "*" && runtime.GOOS == "plan9") {
		hasIPv4 = true
		hasIPv6 = true
	} else {

		// Remove the IPv6 zone from the host, if present.  The zone
		// prevents ParseIP from correctly parsing the IP address.
		// ResolveIPAddr is intentionally not used here due to the
		// possibility of leaking a DNS query over Tor if the host is a
		// hostname and not an IP address.
		zoneIndex := strings.Index(host, "%")
		if zoneIndex != -1 {
			host = host[:zoneIndex]
		}

		ip := net.ParseIP(host)
		switch {
		case ip == nil:
			return nil, fmt.Errorf("`%s` is not a valid IP address", host)
		case ip.To4() == nil:
			hasIPv6 = true
		default:
			hasIPv4 = true
		}
	}
	listeners := make([]net.Listener, 0, 2)
	if hasIPv4 {
		listener, err := net.Listen("tcp4", addr)
		if err != nil {
			return nil, fmt.Errorf("unable to listen on tcp4:%s: %v", addr, err)
		}
		listeners = append(listeners, listener)
	}
	if hasIPv6 {
		listener, err := net.Listen("tcp6", addr)
		if err != nil {
			return nil, fmt.Errorf("unable to listen on tcp6:%s: %v", addr, err)
		}
		listeners = append(listeners, listener)
	}
	return listeners, nil
}

// TLSListeners creates a set of TLS listeners based on the specified config.
func TLSListeners(cfg TLSListenersConfig) ([]net.Listener, error) {
	log := cfg.Log
	if log == nil {
		log = slog.Disabled
	}

	// First attempt at loading the keypair.
	cert, err := tls.LoadX509KeyPair(cfg.CertPath, cfg.KeyPath)
	if os.IsNotExist(err) && cfg.CreateCertPairIfNotExists {
		// Generate keypair.
		cert, err = generateKeyPair(cfg.CertPath, cfg.KeyPath)
		if err != nil {
			return nil, fmt.Errorf("unable to generate new TLS keypair: %v", err)
		}
		log.Infof("Generated RPC Key and Cert files")
		log.Debugf("Generated RPC Key file: %s", cfg.KeyPath)
		log.Debugf("Generated RPC Cert file: %s", cfg.CertPath)
	}
	if err != nil {
		return nil, fmt.Errorf("unable to read TLS keypair: %v", err)
	}

	// Base TLS config.
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
		MinVersion:   tls.VersionTLS12,
	}

	// Setup client cert auth.
	if cfg.ClientCAPath != "" {
		tlsConfig.ClientCAs = x509.NewCertPool()
		tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
		caFile, err := os.ReadFile(cfg.ClientCAPath)
		if os.IsNotExist(err) && cfg.CreateClientCertIfNotExists {
			caFile, err = generateClientCert(cfg.ClientCAPath,
				cfg.ClientCertPath, cfg.ClientKeyPath)
			if err != nil {
				return nil, fmt.Errorf("unable to generate client certs: %v", err)
			}
			log.Infof("Generated CA and client certificates")
			log.Debugf("Generated client CA file: %s", cfg.ClientCAPath)
		}
		if err != nil {
			return nil, fmt.Errorf("unable to read client CA file: %v", err)
		}
		if !tlsConfig.ClientCAs.AppendCertsFromPEM(caFile) {
			return nil, fmt.Errorf("unable to append client CA file to config")
		}
	}

	// Listen on addresses with TLS.
	res := make([]net.Listener, 0, len(cfg.Addresses)*2)
	for _, addr := range cfg.Addresses {
		listeners, err := listen(addr)
		if err != nil {
			return nil, err
		}
		for _, lis := range listeners {
			tlsLis := tls.NewListener(lis, tlsConfig)
			res = append(res, tlsLis)
		}
	}

	return res, nil
}
